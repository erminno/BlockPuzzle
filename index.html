<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <!-- Viewport ottimizzata -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Block Puzzle - Ultimate Gold</title>
    <style>
        :root {
            --bg-color: #121212;
            --board-bg: #1e1e24;
            --cell-empty: #2a2a35;
            --text-color: #FFD700; 
            --text-secondary: #FFA500;
            --highlight: rgba(255, 215, 0, 0.2);
            --gap: 4px;
            --radius: 12px;
            --btn-radius: 50px;
            --danger: #ff4444;
            --success: #4CAF50;
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 50%, #2a2a35 0%, #121212 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            padding-top: 10px;
            padding-bottom: var(--safe-bottom);
            touch-action: none;
        }

        .scrollable { touch-action: pan-y !important; }

        /* --- Performance Mode Overrides --- */
        body.performance-mode .particle { display: none !important; }
        body.performance-mode .shake-effect { animation: none !important; transform: none !important; }
        body.performance-mode .board-pulse { animation: none !important; box-shadow: none !important; }
        body.performance-mode .menu-title { animation: none !important; text-shadow: 2px 2px 0px #8B4513; }
        body.performance-mode .floating-text { animation: none !important; opacity: 1; transition: opacity 0.5s; transform: translateY(-30px); }
        body.performance-mode .cell.filled { box-shadow: inset 0 0 0 1px rgba(255,255,255,0.1) !important; }
        body.performance-mode .cell.filled::after { display: none; }
        body.performance-mode #main-menu { transition: none; }
        body.performance-mode .modal-content { box-shadow: 0 5px 20px rgba(0,0,0,0.5); transition: none; }

        /* --- PARTICELLE ED EFFETTI --- */
        #particles-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 150;
        }

        .particle {
            position: absolute;
            background: var(--text-color);
            border-radius: 50%;
            pointer-events: none;
            animation: particle-fade 0.8s forwards ease-out;
        }

        @keyframes particle-fade {
            0% { transform: translate(0,0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        .shake-effect { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }

        .board-pulse {
            animation: gridPulse 1.5s infinite alternate;
            border-color: rgba(255, 215, 0, 0.4) !important;
        }

        @keyframes gridPulse {
            from { box-shadow: 0 0 10px rgba(255, 215, 0, 0.1); }
            to { box-shadow: 0 0 25px rgba(255, 215, 0, 0.3); }
        }

        /* --- SCHERMATA INTRO --- */
        #intro-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--bg-color);
            z-index: 300;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease-in-out;
            pointer-events: auto; 
        }

        .loader-text-container {
            position: relative;
            margin-bottom: 20px;
            perspective: 500px;
            width: 90%;
            display: flex;
            justify-content: center;
        }

        #intro-text {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: transparent;
            background: linear-gradient(180deg, #FFD700 20%, #B8860B 80%);
            -webkit-background-clip: text;
            background-clip: text;
            text-align: center;
            opacity: 0;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
            transform-style: preserve-3d;
            transition: all 0.5s ease;
        }

        #intro-subtext {
            font-size: 1rem;
            color: #888;
            margin-top: 10px;
            opacity: 0;
            font-family: monospace;
            letter-spacing: 2px;
            transition: opacity 0.5s;
        }

        .intro-visible { opacity: 1 !important; transform: scale(1.1); }

        .loading-bar-bg {
            width: 200px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 30px;
            overflow: hidden;
            position: relative;
        }

        .loading-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            box-shadow: 0 0 10px #FFD700;
            transition: width 0.3s ease-out;
        }

        /* --- NOTIFICATIONS --- */
        #notification-area {
            position: fixed;
            top: 5vh;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            width: 90%;
            max-width: 400px;
            align-items: center;
        }

        .notification-toast {
            background: rgba(30, 30, 36, 0.95);
            border: 2px solid var(--text-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.8), 0 0 15px rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            animation: slideDown 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards, fadeOut 0.5s ease-in 3.5s forwards;
            backdrop-filter: blur(8px);
            width: 100%;
        }
        
        .notif-icon { font-size: 2.5rem; filter: drop-shadow(0 0 5px gold); }
        .notif-content { text-align: left; flex: 1; }
        .notif-title { 
            color: var(--text-color); 
            font-weight: 900; 
            font-size: 1.2rem; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            margin-bottom: 4px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }
        .notif-desc { color: #fff; font-size: 0.95rem; font-weight: 600; }

        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes fadeOut {
            to { opacity: 0; transform: translateY(-30px); pointer-events: none; }
        }

        /* --- MENU PRINCIPALE --- */
        #main-menu {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--bg-color);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #main-menu.hidden {
            transform: translateY(-100%) scale(0.9);
            opacity: 0;
            pointer-events: none;
        }

        .menu-title {
            font-size: clamp(3rem, 12vw, 5rem); 
            background: linear-gradient(to bottom, #FFD700, #FDB931, #996515);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
            filter: drop-shadow(0 5px 0 #8B4513) drop-shadow(0 15px 15px rgba(0,0,0,0.5));
            text-align: center;
            font-weight: 900;
            line-height: 1.1;
            animation: titleFloat 4s ease-in-out infinite;
            padding: 0 10px;
        }

        @keyframes titleFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        .menu-btn {
            background: linear-gradient(135deg, #FFD700, #ffb900);
            color: #1a1a2e;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: var(--btn-radius);
            cursor: pointer;
            margin: 8px;
            width: 85%;
            max-width: 320px;
            font-weight: 800;
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.3);
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover { transform: translateY(-2px); box-shadow: 0 15px 30px rgba(255, 215, 0, 0.4); }
        .menu-btn:active { transform: scale(0.95) translateY(0); box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2); }
        
        .btn-click-effect { transform: scale(0.92) !important; filter: brightness(1.2); }

        .menu-btn.secondary {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--text-color);
            color: var(--text-color);
            box-shadow: none;
        }
        .menu-btn.secondary:hover { background: rgba(255, 215, 0, 0.1); }

        .menu-btn.expert {
            background: linear-gradient(135deg, #ff4e50, #f9d423);
            color: #1a1a2e;
        }

        .extra-btn-container {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            justify-content: center;
            flex-wrap: wrap; 
            max-width: 340px;
        }

        .extra-menu-btn {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--text-color);
            color: white;
            font-size: 1.4rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative; 
        }

        .extra-menu-btn:hover { background: rgba(255,215,0,0.2); transform: scale(1.1); }

        .notification-badge {
            position: absolute;
            top: -5px; right: -5px;
            width: 18px; height: 18px;
            background-color: #ff4444;
            border-radius: 50%;
            border: 2px solid #121212;
            display: none;
            box-shadow: 0 0 5px #ff4444;
            animation: pulse-badge 1.5s infinite;
        }
        .notification-badge.active { display: block; }
        #news-badge { background-color: #00E5FF; box-shadow: 0 0 5px #00E5FF; }
        
        @keyframes pulse-badge {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .settings-btn-main {
            position: absolute;
            top: 20px; right: 20px;
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--text-color);
            color: var(--text-color);
            width: 45px; height: 45px;
            border-radius: 50%;
            font-size: 1.4rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 201;
        }

        /* --- UI DI GIOCO --- */
        .top-bar {
            width: 95vw;
            max-width: 450px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
            padding-top: 5px;
        }
        
        .icon-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-color);
            font-size: 1.2rem;
            cursor: pointer;
            width: 40px; height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            margin-right: 5px;
        }

        .stats-row {
            width: 95vw;
            max-width: 450px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding: 0 5px;
        }

        .coin-display {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            padding: 4px 10px;
            border-radius: 20px;
            border: 1px solid var(--text-color);
            font-weight: bold;
            color: var(--text-color);
            gap: 5px;
            font-size: 0.9rem;
        }

        .level-container {
            flex-grow: 1;
            margin-left: 10px;
            margin-right: 5px;
        }

        .level-text {
            font-size: 0.75rem;
            color: #aaa;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
        }

        .level-bar-bg {
            height: 5px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .level-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.5s ease-out;
        }

        .score-container {
            display: flex;
            gap: 5px;
            flex: 1;
            justify-content: flex-end;
        }

        .score-box {
            background: var(--board-bg);
            padding: 5px 10px;
            border-radius: 15px;
            text-align: center;
            min-width: 60px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            border: 1px solid rgba(255, 215, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .score-box.timer {
            border: 1px solid var(--text-color);
            background: rgba(255, 215, 0, 0.1);
            display: none; 
        }
        .score-box.timer.active { display: block; }

        .score-label {
            font-size: 0.55rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 2px;
        }

        .score-value { font-size: 1rem; font-weight: 800; color: white; }
        #score { color: var(--text-color); }

        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            background-color: var(--board-bg);
            padding: 4px;
            border-radius: 16px;
            width: 92vw;
            height: 92vw;
            max-width: 45vh; 
            max-height: 45vh;
            position: relative;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 1px solid rgba(255, 215, 0, 0.1);
            transition: border-color 0.3s;
            margin-bottom: 10px;
            touch-action: none;
        }

        @media (min-width: 500px) and (min-height: 600px) {
             #game-board {
                width: 400px; height: 400px;
                max-width: none; max-height: none;
                gap: 4px; padding: 6px;
             }
        }

        #game-board.bomb-active {
            border: 2px solid #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
        }
        
        #game-board.bomb-active .cell:hover { background-color: rgba(255, 68, 68, 0.3); }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 4px;
            width: 100%; height: 100%;
            transition: background-color 0.15s ease-out;
        }

        .cell.filled {
            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.2), inset 0 2px 5px rgba(255,255,255,0.4);
            position: relative;
        }
        
        .cell.filled::after {
            content: '';
            position: absolute;
            top: 10%; left: 10%;
            width: 40%; height: 40%;
            background: radial-gradient(circle at top left, rgba(255,255,255,0.6), transparent);
            border-radius: 2px;
        }

        .cell.preview {
            background-color: rgba(255, 215, 0, 0.2) !important;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.2);
            transform: scale(0.9);
            border-radius: 4px;
            border: 1px dashed rgba(255,215,0,0.5);
        }

        .cell.clearing {
            animation: vanish 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            z-index: 10;
        }

        @keyframes vanish {
            0% { transform: scale(1); filter: brightness(2) drop-shadow(0 0 10px gold); background-color: #fff; }
            100% { transform: scale(0); opacity: 0; }
        }

        .floating-text {
            position: absolute;
            font-size: 2rem;
            font-weight: 900;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 160;
            width: 100%;
            text-align: center;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }

        /* --- POWER UPS --- */
        #powerups-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 5px;
            width: 95vw;
            max-width: 400px;
            flex-shrink: 0; 
        }

        .powerup-btn {
            background: linear-gradient(145deg, #2a2a35, #1e1e24);
            border: 1px solid #444;
            border-radius: 12px;
            padding: 6px 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #ccc;
            cursor: pointer;
            transition: all 0.2s;
            width: 30%;
            max-width: 80px;
            position: relative;
            overflow: hidden;
        }

        .powerup-btn:active { transform: scale(0.95); }
        .powerup-btn.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .powerup-btn.affordable {
            border-color: var(--text-color);
            color: white;
            background: linear-gradient(145deg, #2a2a35, #252515);
        }
        .powerup-btn.active-mode {
            background: var(--text-color);
            color: #121212;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }

        .powerup-icon { font-size: 1.2rem; margin-bottom: 2px; }
        .powerup-cost { font-size: 0.65rem; display: flex; align-items: center; gap: 2px; color: #888; }
        .affordable .powerup-cost { color: #FFD700; }

        /* Container Pezzi */
        #pieces-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 98vw;
            max-width: 450px;
            height: 120px;
            margin-top: 15px; 
            margin-bottom: auto;
            padding-bottom: 20px;
            touch-action: none;
        }

        @media (max-height: 650px) {
            #pieces-container { height: 90px; margin-top: 5px; }
            .powerup-btn { padding: 4px; }
            .powerup-icon { font-size: 1rem; }
            .menu-title { margin-bottom: 15px; }
        }

        .piece-wrapper {
            width: 30%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s;
        }

        .draggable-piece {
            display: grid;
            gap: 2px;
            cursor: grab;
            transition: transform 0.1s;
            touch-action: none;
            padding: 15px;
        }
        .draggable-piece:active { cursor: grabbing; }

        .piece-cell {
            width: 18px; height: 18px;
            border-radius: 3px;
            pointer-events: none;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.4);
        }
        @media (min-width: 600px) {
            .piece-cell { width: 25px; height: 25px; }
        }

        /* Modals */
        .modal {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(18, 18, 18, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 250; 
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }

        .modal.visible { opacity: 1; pointer-events: all; }

        #reset-confirm-modal { z-index: 260; } /* Ensure it's on top */

        .modal-content {
            background: #232323;
            padding: 25px;
            border-radius: 25px;
            text-align: center;
            border: 1px solid rgba(255, 215, 0, 0.2);
            width: 90%;
            max-width: 380px;
            max-height: 80vh; 
            overflow-y: auto; 
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            touch-action: pan-y;
        }

        .visible .modal-content { transform: scale(1); }

        .modal-title {
            color: var(--text-color); 
            margin: 0 0 10px 0;
            font-size: 1.8rem;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            text-transform: uppercase;
        }
        
        #game-over-reason {
            color: #FFA500;
            font-size: 1rem;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .modal-btn {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #1a1a2e;
            border: none;
            padding: 12px 30px;
            font-size: 1rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 15px;
            font-weight: bold;
            width: 100%;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
            transition: transform 0.1s;
        }

        .modal-btn:active { transform: scale(0.96); }
        .modal-btn:disabled { background: #444; color: #888; cursor: not-allowed; box-shadow: none; }
        
        .stats-list, .achievements-list {
            text-align: left;
            width: 100%;
            margin-top: 10px;
            max-height: 40vh;
            overflow-y: auto;
            padding-right: 5px;
            scrollbar-width: thin;
            touch-action: pan-y;
        }

        .category-header {
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            color: var(--text-color);
            font-weight: 800;
            text-transform: uppercase;
            padding: 5px 0;
            margin-top: 15px;
            margin-bottom: 5px;
            border-bottom: 1px solid var(--text-color);
            font-size: 1rem;
            text-align: center;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #ccc;
            font-size: 0.9rem;
        }
        
        .stat-val { color: var(--text-color); font-weight: bold; }
        
        .achievement-item {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 8px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            border: 1px solid transparent;
        }
        
        .achievement-item.unlocked {
            border-color: var(--success);
            background: rgba(76, 175, 80, 0.1);
        }
        
        .ach-icon { font-size: 1.2rem; margin-right: 10px; opacity: 0.5; }
        .unlocked .ach-icon { opacity: 1; }
        
        .ach-info { flex-grow: 1; }
        .ach-title { font-weight: bold; color: #fff; font-size: 0.85rem; }
        .ach-desc { font-size: 0.7rem; color: #888; }
        .ach-status { font-size: 1rem; }

        /* Settings Style */
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            width: 100%;
            color: #ccc;
            font-size: 1rem;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 45px;
            height: 24px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #FFD700; }
        input:checked + .slider:before { transform: translateX(21px); background-color: #1a1a2e; }

        /* Custom Range Slider */
        .range-slider {
            -webkit-appearance: none;
            width: 100px;
            height: 6px;
            border-radius: 5px;
            background: #444;
            outline: none;
            margin-left: 10px;
        }
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FFD700;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255,215,0,0.5);
        }

        .lang-switch-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
            margin-bottom: 20px;
        }
        
        .lang-btn {
            padding: 8px 15px;
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            color: #888;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            font-size: 1.2rem;
        }
        
        .lang-btn.active {
            border-color: var(--text-color);
            color: white;
            background: rgba(255,215,0,0.1);
        }

        #update-modal .modal-content {
            max-width: 600px; 
            width: 95%;
            padding: 30px 20px;
        }

        .update-feature {
            background: linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,215,0,0.05));
            border-left: 4px solid var(--text-color);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            text-align: left;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        
        .update-title-text {
            display: block;
            color: var(--text-color);
            font-size: 1.1rem;
            font-weight: 800;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
        
        .update-desc-text { color: #ddd; font-size: 0.9rem; line-height: 1.3; }

        .daily-coins-anim {
            font-size: 3rem;
            animation: bounceIn 1s ease;
            margin: 15px 0;
        }
        @keyframes bounceIn {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); }
        }

        @media (min-width: 768px) {
            body { justify-content: center; } 
            #pieces-container { height: 150px; margin-top: 20px; padding-bottom: 0; }
            .powerup-btn { padding: 10px 15px; max-width: 100px; }
            .powerup-icon { font-size: 1.5rem; }
            .modal-content { padding: 40px; }
            .menu-title { font-size: 5rem; }
        }
    </style>
</head>
<body>

    <div id="particles-container"></div>
    <div id="notification-area"></div>

    <div id="intro-overlay">
        <div class="loader-text-container">
            <div id="intro-text"></div>
        </div>
        <div class="loading-bar-bg">
            <div class="loading-bar-fill" id="intro-bar"></div>
        </div>
        <div id="intro-subtext">Initializing...</div>
    </div>

    <!-- Menu Principale -->
    <div id="main-menu">
        <button class="settings-btn-main" onclick="openSettings()">‚öôÔ∏è</button>

        <h1 class="menu-title">Block<br>Puzzle</h1>
        <button class="menu-btn" onclick="startGame('classic')" data-lang-key="btn_classic">Classica</button>
        <button class="menu-btn secondary" onclick="startGame('time')" data-lang-key="btn_time">A Tempo ‚è±Ô∏è</button>
        <button class="menu-btn expert" onclick="startGame('expert')" data-lang-key="btn_expert">Esperto üî•</button>
        
        <div class="extra-btn-container">
            <button class="extra-menu-btn" onclick="openStats()">üìä</button>
            <button class="extra-menu-btn" onclick="openAchievements()">üèÜ</button>
            <button class="extra-menu-btn" onclick="openDailyReward()">
                üéÅ
                <div class="notification-badge" id="daily-badge"></div>
            </button> 
            <button class="extra-menu-btn" onclick="openUpdates()">
                üì∞
                <div class="notification-badge" id="news-badge"></div>
            </button> 
        </div>
    </div>

    <!-- UI Gioco -->
    <div class="top-bar">
        <div style="display:flex;">
            <button class="icon-btn" onclick="showMainMenu()">üè†</button>
            <button class="icon-btn" onclick="openSettings()">‚öôÔ∏è</button> 
            <button class="icon-btn" onclick="togglePause()">II</button>
        </div>
        <div class="score-container">
             <div class="score-box timer" id="timer-box">
                <div class="score-label" data-lang-key="label_time">Tempo</div>
                <div class="score-value" id="timer">60</div>
            </div>
            <div class="score-box">
                <div class="score-label" data-lang-key="label_score">Punteggio</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="score-box">
                <div class="score-label" data-lang-key="label_record">Record</div>
                <div class="score-value" id="high-score">0</div>
            </div>
        </div>
    </div>

    <div class="stats-row" id="stats-row" style="visibility: hidden;">
        <div class="coin-display">
            <span>ü™ô</span>
            <span id="coin-value">100</span>
        </div>
        <div class="level-container">
            <div class="level-text">
                <span id="level-label">Lvl 1</span>
                <span id="combo-display" style="color:#FFD700; font-weight:bold; opacity:0;">x2 COMBO!</span>
            </div>
            <div class="level-bar-bg">
                <div class="level-bar-fill" id="level-bar"></div>
            </div>
        </div>
    </div>

    <div id="game-board" onclick="handleBoardClick(event)">
        <!-- Generato via JS -->
    </div>

    <div id="powerups-container" style="visibility: hidden;">
        <button class="powerup-btn" id="btn-rotate" onclick="usePowerup('rotate')">
            <div class="powerup-icon">üîÑ</div>
            <div class="powerup-cost">50 ü™ô</div>
        </button>
        <button class="powerup-btn" id="btn-reroll" onclick="usePowerup('reroll')">
            <div class="powerup-icon">üé≤</div>
            <div class="powerup-cost">50 ü™ô</div>
        </button>
        <button class="powerup-btn" id="btn-bomb" onclick="usePowerup('bomb')">
            <div class="powerup-icon">üí£</div>
            <div class="powerup-cost">50 ü™ô</div>
        </button>
    </div>

    <div id="pieces-container">
        <!-- Pezzi generati qui -->
    </div>

    <!-- Modal Game Over -->
    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h1 class="modal-title" data-lang-key="modal_gameover">Game Over!</h1>
            <div id="game-over-reason"></div>
            
            <p style="color:#889; margin-bottom: 5px; font-size: 0.9rem;" data-lang-key="label_final_score">Punteggio Finale</p>
            <div id="final-score" style="color:white; font-size: 2.5rem; font-weight:800; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255,215,0,0.5);">0</div>
            
            <button class="modal-btn" onclick="restartGame()" data-lang-key="btn_retry">Riprova</button>
            <button class="modal-btn" style="background:transparent; border:2px solid #555; color: #aaa; margin-top:10px; box-shadow:none;" onclick="showMainMenu()" data-lang-key="btn_mainmenu">Menu Principale</button>
        </div>
    </div>

    <!-- Modal Pausa -->
    <div id="pause-modal" class="modal">
        <div class="modal-content">
            <h1 class="modal-title" data-lang-key="modal_pause">Pausa</h1>
            <button class="modal-btn" onclick="togglePause()" data-lang-key="btn_resume">Riprendi</button>
            <button class="modal-btn" style="background:transparent; border:2px solid #555; color: #aaa; margin-top:10px; box-shadow:none;" onclick="showMainMenu()" data-lang-key="btn_exit">Esci</button>
        </div>
    </div>

    <!-- Modal Stats -->
    <div id="stats-modal" class="modal">
        <div class="modal-content scrollable">
            <h1 class="modal-title" data-lang-key="modal_stats">Statistiche</h1>
            <div class="stats-list" id="stats-list-content">
                <!-- JS Filled -->
            </div>
            <button class="modal-btn" onclick="closeModal('stats-modal')" data-lang-key="btn_close">Chiudi</button>
        </div>
    </div>

    <!-- Modal Achievements -->
    <div id="achievements-modal" class="modal">
        <div class="modal-content scrollable">
            <h1 class="modal-title" data-lang-key="label_achievements">Obiettivi</h1>
            <div class="achievements-list" id="achievements-list-content">
                <!-- JS Filled -->
            </div>
            <button class="modal-btn" onclick="closeModal('achievements-modal')" data-lang-key="btn_close">Chiudi</button>
        </div>
    </div>

    <!-- Modal Settings -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <h1 class="modal-title" data-lang-key="modal_settings">Impostazioni</h1>
            <p style="color:#aaa; margin-bottom:5px;" data-lang-key="label_language">Lingua / Language</p>
            <div class="lang-switch-container">
                <button class="lang-btn active" id="btn-lang-it" onclick="setLanguage('it')">üáÆüáπ</button>
                <button class="lang-btn" id="btn-lang-en" onclick="setLanguage('en')">üá¨üáß</button>
            </div>
            <div class="setting-row">
                <span data-lang-key="opt_sound">Suoni</span>
                <label class="switch">
                    <input type="checkbox" id="chk-sound" checked onchange="toggleSound(this.checked)">
                    <span class="slider"></span>
                </label>
            </div>
            
            <div class="setting-row">
                <span data-lang-key="opt_perf">Modalit√† Performance</span>
                <label class="switch">
                    <input type="checkbox" id="chk-perf" onchange="togglePerformance(this.checked)">
                    <span class="slider"></span>
                </label>
            </div>
            
            <!-- MODIFICA: Bottone Reset -->
            <button class="modal-btn" style="background: var(--danger); margin-top: 20px;" onclick="openResetConfirm()" data-lang-key="btn_reset">Reset Dati</button>
            <button class="modal-btn" style="margin-top:10px; background:transparent; border: 1px solid #555; box-shadow:none; color: white;" onclick="closeSettings()" data-lang-key="btn_close">Chiudi</button>
        </div>
    </div>

    <!-- Modal Reset Confirm -->
    <div id="reset-confirm-modal" class="modal">
        <div class="modal-content">
            <h1 class="modal-title" style="color: var(--danger);" data-lang-key="modal_reset_title">Sei Sicuro?</h1>
            <p data-lang-key="modal_reset_desc" style="margin-bottom:20px; color:#ddd;">Tutti i progressi (livello, monete, record) verranno cancellati per sempre.</p>
            <div style="display:flex; gap:10px; justify-content:center;">
                <button class="modal-btn" style="background: transparent; border: 1px solid #555; width:45%; color: white;" onclick="closeModal('reset-confirm-modal')" data-lang-key="btn_cancel">Annulla</button>
                <button class="modal-btn" style="background: var(--danger); width:45%;" onclick="performFactoryReset()" data-lang-key="btn_yes_reset">S√¨, Cancella</button>
            </div>
        </div>
    </div>

    <!-- Modal Novit√† -->
    <div id="update-modal" class="modal">
        <div class="modal-content">
            <h1 class="modal-title" style="font-size: 2rem;" data-lang-key="update_title">Novit√† v2.9!</h1>
            <div class="update-feature">
                <div class="update-title-text" data-lang-key="update_lvl_title">‚¨ÜÔ∏è Level Up Rapido</div>
                <div class="update-desc-text" data-lang-key="update_lvl_desc">Il passaggio di livello ora √® una notifica e non ferma il gioco!</div>
            </div>
             <div class="update-feature">
                <div class="update-title-text" data-lang-key="update_sound_title">üîä Suoni</div>
                <div class="update-desc-text" data-lang-key="update_sound_desc">Ripristinati i click dei tasti!</div>
            </div>
            <button class="modal-btn" onclick="closeModal('update-modal')" data-lang-key="btn_close">Fantastico!</button>
        </div>
    </div>

    <!-- Modal Daily Reward -->
    <div id="daily-modal" class="modal">
        <div class="modal-content">
            <h1 class="modal-title" data-lang-key="daily_title">Ricompensa Giornaliera</h1>
            <p data-lang-key="daily_desc">Bentornato! Ecco le tue monete.</p>
            <div class="daily-coins-anim">üí∞ 150</div>
            <button class="modal-btn" id="btn-claim-daily" onclick="claimDailyReward()" data-lang-key="btn_claim">Raccogli</button>
        </div>
    </div>

<script>
    const BOARD_SIZE = 8;
    const board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
    const APP_VERSION = "2.9"; 
    
    // TRADUZIONI COMPLETE
    const TRANSLATIONS = {
        it: {
            btn_classic: "Classica",
            btn_time: "A Tempo ‚è±Ô∏è",
            btn_expert: "Esperto üî•",
            label_time: "Tempo",
            label_score: "Punteggio",
            label_record: "Record",
            label_achievements: "Obiettivi",
            modal_gameover: "Game Over!",
            label_final_score: "Punteggio Finale",
            btn_retry: "Riprova",
            btn_mainmenu: "Menu Principale",
            modal_pause: "Pausa",
            btn_resume: "Riprendi",
            btn_exit: "Esci",
            modal_settings: "Impostazioni",
            modal_stats: "Statistiche",
            label_language: "Lingua / Language",
            btn_close: "Chiudi",
            opt_sound: "Suoni",
            opt_perf: "Modalit√† Performance",
            reason_timeout: "Tempo Scaduto! ‚è≥",
            reason_nomoves: "Nessuno spazio! üß±",
            reason_generic: "Partita Finita",
            update_title: "Novit√† v2.9",
            update_lvl_title: "‚¨ÜÔ∏è Level Up Rapido",
            update_lvl_desc: "Il level up ora √® una notifica e non ferma il gioco!",
            update_sound_title: "üîä Suoni",
            update_sound_desc: "Ripristinati i suoni dei tasti.",
            daily_title: "Ricompensa Giornaliera",
            daily_desc: "Bentornato! Ecco un regalo per te.",
            btn_claim: "Raccogli",
            daily_wait: "Torna domani! üïõ",
            // Reset
            btn_reset: "Reset Dati",
            modal_reset_title: "Sei Sicuro?",
            modal_reset_desc: "Tutti i progressi (livello, monete, record) verranno cancellati per sempre.",
            btn_cancel: "Annulla",
            btn_yes_reset: "S√¨, Cancella Tutto",
            // Stats
            stat_total_games: "Partite Totali",
            stat_level: "Livello",
            stat_total_lines: "Linee Totali",
            stat_header_gen: "GENERALE",
            stat_header_rec: "RECORD",
            // Cats
            cat_gen: "Generale",
            cat_classic: "Classica",
            cat_time: "A Tempo",
            cat_exp: "Esperto",
            // Achievements Titles & Desc
            ach_novice: "Novizio", ach_desc_novice: "Ottieni 100 punti",
            ach_survivor: "Sopravvissuto", ach_desc_survivor: "Raggiungi il livello 5",
            ach_rich: "Riccone", ach_desc_rich: "Accumula 500 monete",
            ach_lines_expert: "Esperto di Linee", ach_desc_lines_expert: "Pulisci 100 linee totali",
            ach_quad_clear: "Spazzino", ach_desc_quad_clear: "Pulisci 4+ linee in una volta",
            ach_combo_master: "Combo Master", ach_desc_combo_master: "Raggiungi una combo x5",
            ach_bomber: "Bombarolo", ach_desc_bomber: "Usa la Bomba",
            ach_lucky_hand: "Mano Fortunata", ach_desc_lucky_hand: "Usa il Reroll",
            ach_time_is_money: "Il Tempo √® Denaro", ach_desc_time_is_money: "Fai 500 punti in modalit√† Tempo",
            ach_chrononaut: "Signore del Tempo", ach_desc_chrononaut: "Raggiungi 2000 punti in A Tempo",
            ach_panic_mode: "Panico!", ach_desc_panic_mode: "Pulisci linea con <5 sec rimasti",
            ach_time_hoarder: "Accumulatore", ach_desc_time_hoarder: "Accumula 80+ secondi",
            ach_strategist: "Strategista", ach_desc_strategist: "Gioca in modalit√† Esperto",
            ach_grand_master: "Gran Maestro", ach_desc_grand_master: "2000 punti in Esperto",
            ach_purist: "Purista", ach_desc_purist: "500 pt in Esperto senza Power-up"
        },
        en: {
            btn_classic: "Classic",
            btn_time: "Time Mode ‚è±Ô∏è",
            btn_expert: "Expert üî•",
            label_time: "Time",
            label_score: "Score",
            label_record: "Best",
            label_achievements: "Achievements",
            modal_gameover: "Game Over!",
            label_final_score: "Final Score",
            btn_retry: "Retry",
            btn_mainmenu: "Main Menu",
            modal_pause: "Paused",
            btn_resume: "Resume",
            btn_exit: "Quit",
            modal_settings: "Settings",
            modal_stats: "Statistics",
            label_language: "Language / Lingua",
            btn_close: "Close",
            opt_sound: "Sounds",
            opt_perf: "Performance Mode",
            reason_timeout: "Time's Up! ‚è≥",
            reason_nomoves: "No space left! üß±",
            reason_generic: "Game Over",
            update_title: "What's New v2.9",
            update_lvl_title: "‚¨ÜÔ∏è Fast Level Up",
            update_lvl_desc: "Level up is now a notification and doesn't stop the game!",
            update_sound_title: "üîä Sounds",
            update_sound_desc: "Key sounds restored.",
            daily_title: "Daily Reward",
            daily_desc: "Welcome back! Here is your gift.",
            btn_claim: "Claim",
            daily_wait: "Come back tomorrow! üïõ",
            // Reset
            btn_reset: "Reset Data",
            modal_reset_title: "Are you sure?",
            modal_reset_desc: "All progress (level, coins, records) will be lost forever.",
            btn_cancel: "Cancel",
            btn_yes_reset: "Yes, Delete All",
            // Stats
            stat_total_games: "Total Games",
            stat_level: "Level",
            stat_total_lines: "Total Lines",
            stat_header_gen: "GENERAL",
            stat_header_rec: "RECORDS",
            // Cats
            cat_gen: "General",
            cat_classic: "Classic",
            cat_time: "Time Mode",
            cat_exp: "Expert",
            // Achievements Titles & Desc
            ach_novice: "Novice", ach_desc_novice: "Score 100 points",
            ach_survivor: "Survivor", ach_desc_survivor: "Reach Level 5",
            ach_rich: "Rich", ach_desc_rich: "Collect 500 coins",
            ach_lines_expert: "Lines Expert", ach_desc_lines_expert: "Clear 100 lines total",
            ach_quad_clear: "Sweeper", ach_desc_quad_clear: "Clear 4+ lines at once",
            ach_combo_master: "Combo Master", ach_desc_combo_master: "Reach x5 combo",
            ach_bomber: "Bomber", ach_desc_bomber: "Use the Bomb",
            ach_lucky_hand: "Lucky Hand", ach_desc_lucky_hand: "Use Reroll",
            ach_time_is_money: "Time is Money", ach_desc_time_is_money: "Score 500 in Time Mode",
            ach_chrononaut: "Time Lord", ach_desc_chrononaut: "Score 2000 in Time Mode",
            ach_panic_mode: "Panic!", ach_desc_panic_mode: "Clear line with <5s left",
            ach_time_hoarder: "Hoarder", ach_desc_time_hoarder: "Bank 80+ seconds",
            ach_strategist: "Strategist", ach_desc_strategist: "Play Expert Mode",
            ach_grand_master: "Grand Master", ach_desc_grand_master: "Score 2000 in Expert",
            ach_purist: "Purist", ach_desc_purist: "500 pts Expert no Power-ups"
        }
    };

    const ACHIEVEMENTS_DEF = [
        { id: 'novice', cat: 'gen', check: (s) => s.score >= 100 },
        { id: 'survivor', cat: 'gen', check: (s) => s.level >= 5 },
        { id: 'rich', cat: 'gen', check: (s) => s.coins >= 500 },
        { id: 'lines_expert', cat: 'gen', check: (s, stats) => stats.totalLines >= 100 },
        { id: 'quad_clear', cat: 'gen', event: 'clear', check: (lines) => lines >= 4 },
        { id: 'combo_master', cat: 'gen', event: 'combo', check: (c) => c >= 5 },
        { id: 'bomber', cat: 'gen', event: 'powerup_bomb' },
        { id: 'lucky_hand', cat: 'gen', event: 'powerup_reroll' },
        { id: 'time_is_money', cat: 'time', check: (s) => s.mode === 'time' && s.score >= 500 },
        { id: 'chrononaut', cat: 'time', check: (s) => s.mode === 'time' && s.score >= 2000 },
        { id: 'panic_mode', cat: 'time', event: 'time_panic_clear' },
        { id: 'time_hoarder', cat: 'time', event: 'time_check', check: (t) => t >= 80 },
        { id: 'strategist', cat: 'exp', check: (s) => s.mode === 'expert' },
        { id: 'grand_master', cat: 'exp', check: (s) => s.mode === 'expert' && s.score >= 2000 },
        { id: 'purist', cat: 'exp', check: (s) => s.mode === 'expert' && s.score >= 500 && !s.hasUsedPowerup }
    ];

    let state = {
        score: 0,
        highScore: 0,
        coins: parseInt(localStorage.getItem('blockPuzzleCoins') || 100), 
        level: 1, 
        levelProgress: 0,
        combo: 0, 
        mode: 'classic', 
        timeLeft: 60,
        isPlaying: false,
        isPaused: false,
        timerInterval: null,
        language: 'it',
        soundEnabled: true,
        hapticsEnabled: true, 
        performanceMode: false,
        bombMode: false,
        hasUsedPowerup: false,
        dailyClaimInProgress: false, 
        dailyNotificationCooldown: false,
        pausedBySettings: false
    };
    
    let userStats = JSON.parse(localStorage.getItem('bp_stats')) || {
        classicBest: 0,
        timeBest: 0,
        expertBest: 0,
        lastScore: 0,
        totalGames: 0,
        totalLines: 0,
        currentLevel: 1, 
        currentXP: 0     
    };

    let unlockedAchievements = JSON.parse(localStorage.getItem('bp_achievements')) || [];

    const AudioSys = {
        ctx: null,
        init: function() {
            if (!this.ctx && (window.AudioContext || window.webkitAudioContext)) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
        },
        playTone: function(freq, type, duration, vol=0.1) {
            if (!state.soundEnabled) return; 
            if (!this.ctx) this.init(); 
            if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            
            if(!this.ctx) return; 

            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        playClick: function() { this.playTone(600, 'sine', 0.1, 0.1); }, 
        playPick: function() { this.playTone(400, 'triangle', 0.1, 0.1); },
        playDrop: function() { this.playTone(200, 'sawtooth', 0.15, 0.1); },
        playPowerup: function() { 
            this.playTone(600, 'sine', 0.1, 0.2); 
            setTimeout(()=>this.playTone(900, 'square', 0.2, 0.1), 100);
        },
        playExplosion: function() {
             this.playTone(100, 'sawtooth', 0.3, 0.4); 
             setTimeout(()=>this.playTone(50, 'square', 0.4, 0.3), 50);
        },
        playClear: function() {
            setTimeout(() => this.playTone(500, 'sine', 0.3, 0.1), 0);
            setTimeout(() => this.playTone(750, 'sine', 0.3, 0.1), 100);
            setTimeout(() => this.playTone(1000, 'sine', 0.4, 0.1), 200);
        },
        playCombo: function(mult) {
            let base = 600 + (mult * 100);
            this.playTone(base, 'square', 0.1, 0.1);
            setTimeout(()=>this.playTone(base + 200, 'square', 0.2, 0.1), 100);
        },
        playGameOver: function() {
            setTimeout(() => this.playTone(300, 'sawtooth', 0.5, 0.2), 0);
            setTimeout(() => this.playTone(200, 'sawtooth', 0.5, 0.2), 400);
            setTimeout(() => this.playTone(100, 'sawtooth', 0.8, 0.2), 800);
        },
        playAchievement: function() {
            this.playTone(800, 'sine', 0.2, 0.2);
            setTimeout(() => this.playTone(1200, 'sine', 0.4, 0.2), 150);
        }
    };

    function haptic(ms) {
        if (!state.hapticsEnabled) return;
        if (navigator.vibrate) navigator.vibrate(ms);
        if(ms > 50 && !state.performanceMode) {
             document.body.style.transform = `translate(${Math.random()*2-1}px, ${Math.random()*2-1}px)`;
             setTimeout(() => document.body.style.transform = 'none', 50);
        }
    }

    let dragData = { active: false, element: null, shape: null, color: null, offsetX: 0, offsetY: 0, gridCache: null };
    
    const DOM = {
        board: document.getElementById('game-board'),
        pieces: document.getElementById('pieces-container'),
        score: document.getElementById('score'),
        highScore: document.getElementById('high-score'),
        modal: document.getElementById('game-over-modal'),
        pauseModal: document.getElementById('pause-modal'),
        settingsModal: document.getElementById('settings-modal'),
        statsModal: document.getElementById('stats-modal'),
        achievementsModal: document.getElementById('achievements-modal'),
        updateModal: document.getElementById('update-modal'),
        dailyModal: document.getElementById('daily-modal'),
        dailyBadge: document.getElementById('daily-badge'), 
        newsBadge: document.getElementById('news-badge'),
        finalScore: document.getElementById('final-score'),
        reasonText: document.getElementById('game-over-reason'), 
        menu: document.getElementById('main-menu'),
        timerBox: document.getElementById('timer-box'),
        timerVal: document.getElementById('timer'),
        introOverlay: document.getElementById('intro-overlay'),
        introText: document.getElementById('intro-text'),
        introSub: document.getElementById('intro-subtext'),
        introBar: document.getElementById('intro-bar'),
        particles: document.getElementById('particles-container'),
        statsRow: document.getElementById('stats-row'),
        powerupsContainer: document.getElementById('powerups-container'),
        coinValue: document.getElementById('coin-value'),
        levelLabel: document.getElementById('level-label'),
        levelBar: document.getElementById('level-bar'),
        comboDisplay: document.getElementById('combo-display'),
        btnRotate: document.getElementById('btn-rotate'),
        btnReroll: document.getElementById('btn-reroll'),
        btnBomb: document.getElementById('btn-bomb'),
        statsList: document.getElementById('stats-list-content'),
        achievementsList: document.getElementById('achievements-list-content'),
        notifArea: document.getElementById('notification-area'),
        btnClaimDaily: document.getElementById('btn-claim-daily'),
        chkPerf: document.getElementById('chk-perf')
    };

    window.onload = function() {
        runIntroSequence();
        const savedSound = localStorage.getItem('bp_sound');
        const savedPerf = localStorage.getItem('bp_perf');

        if(savedSound !== null) {
            state.soundEnabled = (savedSound === 'true');
            document.getElementById('chk-sound').checked = state.soundEnabled;
        }
        
        if(savedPerf !== null) {
            state.performanceMode = (savedPerf === 'true');
            DOM.chkPerf.checked = state.performanceMode;
            if(state.performanceMode) document.body.classList.add('performance-mode');
        }
        
        state.level = userStats.currentLevel || 1;
        state.levelProgress = userStats.currentXP || 0;
        updateEconomyUI();
        checkUpdates();
        checkDailyBadge();

        document.body.addEventListener('click', function(e) {
            // Force Init Audio on any interaction
            if (!AudioSys.ctx) AudioSys.init();
            if(AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
            
            const btn = e.target.closest('button');
            if(btn && !btn.disabled) {
                btn.classList.add('btn-click-effect');
                setTimeout(() => btn.classList.remove('btn-click-effect'), 150);
                AudioSys.playClick();
            }
        });
    };

    function togglePerformance(val) {
        state.performanceMode = val;
        localStorage.setItem('bp_perf', val);
        if(val) {
            document.body.classList.add('performance-mode');
        } else {
            document.body.classList.remove('performance-mode');
        }
    }

    function runIntroSequence() {
        const phrases = ["Made by Minno", "Forging Blocks...", "Polishing Gold...", "Ultimate Experience"];
        let step = 0;
        setTimeout(() => DOM.introBar.style.width = '100%', 100);
        function nextPhrase() {
            if (step >= phrases.length) {
                DOM.introOverlay.style.opacity = '0';
                setTimeout(() => {
                    DOM.introOverlay.style.display = 'none';
                    // removed AudioSys.init() from here as it is handled on click
                }, 800);
                return;
            }
            DOM.introText.innerText = phrases[step];
            DOM.introText.classList.add('intro-visible');
            DOM.introSub.style.opacity = '1';
            if (step === phrases.length - 1) DOM.introText.innerHTML = "Block Puzzle<br>Ultimate Gold";
            setTimeout(() => {
                if (step < phrases.length - 1) {
                    DOM.introText.classList.remove('intro-visible');
                    DOM.introSub.style.opacity = '0';
                }
                step++;
                setTimeout(nextPhrase, 500);
            }, 1200);
        }
        nextPhrase();
    }

    function checkUpdates() {
        const lastVer = localStorage.getItem('bp_version');
        if (lastVer !== APP_VERSION) {
            if(DOM.newsBadge) DOM.newsBadge.classList.add('active');
        } else {
            if(DOM.newsBadge) DOM.newsBadge.classList.remove('active');
        }
    }

    function checkDailyBadge() {
        const lastLogin = localStorage.getItem('bp_last_login');
        const today = new Date().toDateString();
        if (lastLogin !== today) DOM.dailyBadge.classList.add('active');
        else DOM.dailyBadge.classList.remove('active');
    }

    function openUpdates() {
        DOM.updateModal.classList.add('visible');
        const lastVer = localStorage.getItem('bp_version');
        if (lastVer !== APP_VERSION) {
            localStorage.setItem('bp_version', APP_VERSION);
            if(DOM.newsBadge) DOM.newsBadge.classList.remove('active');
        }
    }

    function openDailyReward() {
        if (state.dailyNotificationCooldown) return;

        const lastLogin = localStorage.getItem('bp_last_login');
        const today = new Date().toDateString();

        if (lastLogin !== today) {
            state.dailyClaimInProgress = false;
            DOM.btnClaimDaily.disabled = false;
            DOM.btnClaimDaily.innerText = TRANSLATIONS[state.language].btn_claim;
            
            DOM.dailyModal.classList.add('visible');
            AudioSys.playTone(600, 'sine', 0.2);
        } else {
            state.dailyNotificationCooldown = true;

            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0,0,0,0);
            const diff = tomorrow - now;
            const hrs = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const mins = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const timeStr = `${hrs}h ${mins}m`;

            showNotification('‚è≥', 'Attendi...', `${TRANSLATIONS[state.language].daily_wait} (${timeStr})`);
            AudioSys.playTone(150, 'sawtooth', 0.2); 
            
            setTimeout(() => { state.dailyNotificationCooldown = false; }, 3500);
        }
    }

    function claimDailyReward() {
        if (state.dailyClaimInProgress) return;
        state.dailyClaimInProgress = true;
        DOM.btnClaimDaily.disabled = true; 
        DOM.btnClaimDaily.innerText = "‚úì";

        const today = new Date().toDateString();
        localStorage.setItem('bp_last_login', today);
        state.coins += 150;
        updateEconomyUI();
        
        showNotification('üí∞', 'Daily Bonus', '+150 Monete!');
        AudioSys.playAchievement();
        spawnParticles(DOM.coinValue);
        checkDailyBadge();

        setTimeout(() => {
            closeModal('daily-modal');
        }, 600);
    }

    function openResetConfirm() {
        DOM.settingsModal.classList.remove('visible'); // Temporarily hide settings
        document.getElementById('reset-confirm-modal').classList.add('visible');
    }

    function performFactoryReset() {
        // Clear all local storage keys related to the game
        const keys = ['blockPuzzleCoins', 'bp_stats', 'bp_achievements', 'bp_last_login', 'bp_version', 'bp_sound', 'bp_perf'];
        keys.forEach(k => localStorage.removeItem(k));
        
        // Reload page to reset state
        location.reload();
    }

    const COLORS = ['#FF5733', '#33FF57', '#3357FF', '#F333FF', '#00E5FF', '#FFD700', '#FF8C33'];

    const SHAPES_SIMPLE = [
        [[1]], [[1,1]], [[1],[1]],
        [[1,1],[1,1]], 
        [[1,1,1]], [[1],[1],[1]], 
        [[1,1],[1,0]], [[1,1],[0,1]], [[1,0],[1,1]], [[0,1],[1,1]],
        [[1,1,1],[1,0,0]], 
        [[1,1,1],[0,0,1]], 
        [[1,0],[1,0],[1,1]], 
        [[0,1],[0,1],[1,1]], 
        [[0,1,0],[1,1,1]]    
    ];

    const SHAPES_COMPLEX = [
        [[1,1,1,1]], [[1],[1],[1],[1]], 
        [[1,1,1],[0,1,0]], [[0,1,0],[1,1,1]], 
        [[1,1,1],[1,0,0]], [[1,0,0],[1,1,1]], 
        [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], 
        [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]], 
    ];

    const SHAPES_EXPERT_ONLY = [
        [[1,0],[0,1]], [[0,1],[1,0]], 
        [[1,0,1],[1,1,1]], [[1,1,1],[1,0,1]], 
        [[1,1,1],[1,1,1],[1,1,1]], 
        [[1,1,1,1,1]], [[1],[1],[1],[1],[1]], 
        [[1,0,1],[0,1,0],[1,0,1]] 
    ];

    function setLanguage(lang) {
        state.language = lang;
        const texts = TRANSLATIONS[lang];
        document.querySelectorAll('[data-lang-key]').forEach(el => {
            const key = el.getAttribute('data-lang-key');
            if (texts[key]) el.innerText = texts[key];
        });
        document.getElementById('btn-lang-it').classList.toggle('active', lang === 'it');
        document.getElementById('btn-lang-en').classList.toggle('active', lang === 'en');
        // Refresh dynamic lists if open
        if(DOM.statsModal.classList.contains('visible')) openStats();
        if(DOM.achievementsModal.classList.contains('visible')) openAchievements();
    }

    function toggleSound(val) {
        state.soundEnabled = val;
        localStorage.setItem('bp_sound', val);
    }

    function toggleHaptics(val) {
        state.hapticsEnabled = val;
        localStorage.setItem('bp_haptics', val);
        if(val) haptic(200); 
    }

    function openSettings() { 
        if (state.isPlaying && !state.isPaused) {
            togglePause();
            state.pausedBySettings = true; 
        } else {
            state.pausedBySettings = false;
        }
        DOM.settingsModal.classList.add('visible'); 
    }
    
    function closeSettings() {
        DOM.settingsModal.classList.remove('visible');
        if (state.isPlaying && state.isPaused && state.pausedBySettings) {
            togglePause();
            state.pausedBySettings = false;
        }
    }
    
    function closeModal(id) { document.getElementById(id).classList.remove('visible'); }

    function openStats() {
        const t = TRANSLATIONS[state.language];
        let html = `
            <div class="category-header">${t.stat_header_gen}</div>
            <div class="stat-item"><span>${t.stat_total_games}</span><span class="stat-val">${userStats.totalGames}</span></div>
            <div class="stat-item"><span>${t.stat_level}</span><span class="stat-val">${state.level}</span></div>
            <div class="stat-item"><span>${t.stat_total_lines}</span><span class="stat-val">${userStats.totalLines}</span></div>
            <div class="category-header">${t.stat_header_rec}</div>
            <div class="stat-item"><span>${t.cat_classic}</span><span class="stat-val">${userStats.classicBest}</span></div>
            <div class="stat-item"><span>${t.cat_time}</span><span class="stat-val">${userStats.timeBest}</span></div>
            <div class="stat-item"><span>${t.cat_exp}</span><span class="stat-val">${userStats.expertBest}</span></div>
        `;
        DOM.statsList.innerHTML = html;
        DOM.statsModal.classList.add('visible');
    }

    function openAchievements() {
        DOM.achievementsList.innerHTML = ''; 
        const t = TRANSLATIONS[state.language];
        const cats = ['gen', 'classic', 'time', 'exp'];
        const catTitles = {
            'gen': t.cat_gen,
            'classic': t.cat_classic,
            'time': t.cat_time,
            'exp': t.cat_exp
        };

        cats.forEach(cat => {
            const items = ACHIEVEMENTS_DEF.filter(a => a.cat === cat);
            if(items.length === 0) return;
            const header = document.createElement('div');
            header.className = 'category-header';
            header.innerText = catTitles[cat];
            DOM.achievementsList.appendChild(header);
            items.forEach(ach => {
                const isUnlocked = unlockedAchievements.includes(ach.id);
                // Look up translation keys based on ID
                const title = t[`ach_${ach.id}`];
                const desc = t[`ach_desc_${ach.id}`];
                
                const div = document.createElement('div');
                div.className = `achievement-item ${isUnlocked ? 'unlocked' : ''}`;
                div.innerHTML = `
                    <div class="ach-icon">${isUnlocked ? 'üèÜ' : 'üîí'}</div>
                    <div class="ach-info">
                        <div class="ach-title">${title}</div>
                        <div class="ach-desc">${desc}</div>
                    </div>
                    <div class="ach-status">${isUnlocked ? '‚úÖ' : ''}</div>
                `;
                DOM.achievementsList.appendChild(div);
            });
        });
        DOM.achievementsModal.classList.add('visible');
    }

    function checkAchievements(eventName, eventVal) {
        let changed = false;
        const t = TRANSLATIONS[state.language];
        ACHIEVEMENTS_DEF.forEach(ach => {
            if (unlockedAchievements.includes(ach.id)) return;
            let passed = false;
            if (ach.event) {
                if (ach.event === eventName) {
                    if (ach.check) passed = ach.check(eventVal);
                    else passed = true;
                }
            } else if (ach.check) {
                passed = ach.check(state, userStats);
            }
            if (passed) {
                unlockedAchievements.push(ach.id);
                localStorage.setItem('bp_achievements', JSON.stringify(unlockedAchievements));
                // Use translated title for notification
                showNotification('üèÜ', t.label_achievements, t[`ach_${ach.id}`]);
                AudioSys.playAchievement();
                changed = true;
            }
        });
    }

    function showNotification(icon, title, desc) {
        if (DOM.notifArea.children.length > 2) {
            DOM.notifArea.removeChild(DOM.notifArea.firstChild);
        }

        const notif = document.createElement('div');
        notif.className = 'notification-toast';
        notif.innerHTML = `
            <div class="notif-icon">${icon}</div>
            <div class="notif-content">
                <div class="notif-title">${title}</div>
                <div class="notif-desc">${desc}</div>
            </div>
        `;
        DOM.notifArea.appendChild(notif);
        setTimeout(() => {
            if(notif.parentNode) notif.parentNode.removeChild(notif);
        }, 3500);
    }

    function showMainMenu() {
        stopTimer();
        DOM.modal.classList.remove('visible');
        DOM.pauseModal.classList.remove('visible');
        DOM.menu.classList.remove('hidden');
        DOM.statsRow.style.visibility = 'hidden';
        DOM.powerupsContainer.style.visibility = 'hidden';
        state.isPlaying = false;
        state.isPaused = false;
    }

    function startGame(mode) {
        AudioSys.init();
        state.mode = mode;
        state.score = 0; 
        state.combo = 0;
        state.isPlaying = true;
        state.isPaused = false;
        state.bombMode = false;
        state.hasUsedPowerup = false;
        
        if(mode === 'classic') state.highScore = userStats.classicBest;
        else if(mode === 'time') state.highScore = userStats.timeBest;
        else if(mode === 'expert') state.highScore = userStats.expertBest;
        DOM.highScore.innerText = state.highScore;

        DOM.settingsModal.classList.remove('visible'); 
        DOM.statsRow.style.visibility = 'visible';
        DOM.powerupsContainer.style.visibility = 'visible';
        DOM.board.classList.remove('bomb-active');
        DOM.btnBomb.classList.remove('active-mode');

        if (mode === 'expert') DOM.btnReroll.classList.add('disabled');
        else DOM.btnReroll.classList.remove('disabled');

        if (mode === 'time') {
            state.timeLeft = 60;
            DOM.timerBox.classList.add('active');
            updateTimerDisplay();
            startTimer();
        } else DOM.timerBox.classList.remove('active');

        updateScore(0);
        updateLevelUI(); 
        updateEconomyUI();
        createBoardGrid();
        for(let r=0; r<BOARD_SIZE; r++) board[r].fill(null);
        updateBoardUI(); 

        spawnPieces();
        DOM.menu.classList.add('hidden');
        DOM.modal.classList.remove('visible');
        DOM.pauseModal.classList.remove('visible');
        checkAchievements('start');
    }

    function restartGame() { startGame(state.mode); }

    function togglePause() {
        if (!state.isPlaying) return;
        state.isPaused = !state.isPaused;
        
        if (state.isPaused) {
            stopTimer();
            DOM.pauseModal.classList.add('visible');
        } else {
            if (state.mode === 'time') startTimer();
            DOM.pauseModal.classList.remove('visible');
        }
    }

    function createBoardGrid() {
        DOM.board.innerHTML = '';
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.r = r;
                cell.dataset.c = c;
                DOM.board.appendChild(cell);
            }
        }
    }

    function updateEconomyUI() {
        DOM.coinValue.innerText = state.coins;
        localStorage.setItem('blockPuzzleCoins', state.coins);
        
        DOM.btnRotate.classList.toggle('affordable', state.coins >= 50);
        DOM.btnReroll.classList.toggle('affordable', state.coins >= 50 && state.mode !== 'expert');
        DOM.btnBomb.classList.toggle('affordable', state.coins >= 50);
        checkAchievements('coins');
    }

    function usePowerup(type) {
        if(!state.isPlaying || state.isPaused) return;
        state.hasUsedPowerup = true;
        const COST = 50; 

        if (type === 'rotate') {
            if (state.coins >= COST) {
                state.coins -= COST;
                AudioSys.playPowerup();
                rotateAllPieces();
                updateEconomyUI();
                spawnParticles(DOM.btnRotate); 
            } else failPowerup(DOM.btnRotate);

        } else if (type === 'reroll') {
            if (state.mode === 'expert') return; 
            if (state.coins >= COST) {
                state.coins -= COST;
                AudioSys.playPowerup();
                spawnPieces(); 
                updateEconomyUI();
                spawnParticles(DOM.btnReroll);
                checkAchievements('powerup_reroll');
            } else failPowerup(DOM.btnReroll);

        } else if (type === 'bomb') {
            if (state.coins >= COST) {
                if (state.bombMode) {
                    state.bombMode = false;
                    DOM.board.classList.remove('bomb-active');
                    DOM.btnBomb.classList.remove('active-mode');
                } else {
                    state.bombMode = true;
                    DOM.board.classList.add('bomb-active');
                    DOM.btnBomb.classList.add('active-mode');
                    showFloatingText("BOMB MODE!");
                }
            } else failPowerup(DOM.btnBomb);
        }
    }
    
    function failPowerup(btn) {
        AudioSys.playTone(150, 'sawtooth', 0.2); 
        btn.classList.add('shake-effect');
        setTimeout(()=>btn.classList.remove('shake-effect'), 400);
    }

    function rotateAllPieces() {
        const wrappers = document.querySelectorAll('.piece-wrapper');
        wrappers.forEach(w => {
            const piece = w.querySelector('.draggable-piece');
            if (piece) {
                const oldShape = JSON.parse(piece.dataset.shape);
                const color = piece.dataset.color;
                const rows = oldShape.length;
                const cols = oldShape[0].length;
                let newShape = Array(cols).fill().map(() => Array(rows).fill(0));
                for(let i=0; i<rows; i++) {
                    for(let j=0; j<cols; j++) {
                        newShape[j][rows-1-i] = oldShape[i][j];
                    }
                }
                w.innerHTML = '';
                const newEl = createPieceElement(newShape, color);
                w.appendChild(newEl);
                newEl.addEventListener('pointerdown', startDrag);
                newEl.style.transform = "rotate(90deg) scale(0)";
                setTimeout(()=> newEl.style.transform = "rotate(0deg) scale(1)", 50);
            }
        });
        checkGameOverCondition();
    }

    function handleBoardClick(e) {
        if (!state.bombMode) return;
        const cell = e.target.closest('.cell');
        if (!cell) return;
        const r = parseInt(cell.dataset.r);
        const c = parseInt(cell.dataset.c);
        AudioSys.playExplosion();
        haptic(100);
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const tr = r + i;
                const tc = c + j;
                if(tr>=0 && tr<BOARD_SIZE && tc>=0 && tc<BOARD_SIZE) {
                    if (board[tr][tc] !== null) {
                        board[tr][tc] = null;
                        const tCell = document.querySelector(`.cell[data-r="${tr}"][data-c="${tc}"]`);
                        if(tCell) {
                            tCell.classList.add('clearing');
                            spawnParticles(tCell);
                        }
                    }
                }
            }
        }
        setTimeout(() => {
            updateBoardUI();
            document.querySelectorAll('.clearing').forEach(el => el.classList.remove('clearing'));
        }, 300);

        state.coins -= 50;
        updateEconomyUI();
        state.bombMode = false;
        DOM.board.classList.remove('bomb-active');
        DOM.btnBomb.classList.remove('active-mode');
        checkAchievements('powerup_bomb');
    }

    function startTimer() {
        stopTimer();
        state.timerInterval = setInterval(() => {
            if (state.isPaused) return;
            state.timeLeft--;
            updateTimerDisplay();
            checkAchievements('time_check', state.timeLeft);
            if (state.timeLeft <= 0) {
                stopTimer();
                triggerGameOver('timeout');
            }
        }, 1000);
    }

    function stopTimer() { if (state.timerInterval) clearInterval(state.timerInterval); }

    function updateTimerDisplay() {
        DOM.timerVal.innerText = state.timeLeft;
        if (state.timeLeft <= 10) DOM.timerVal.style.color = '#ff4444';
        else DOM.timerVal.style.color = 'var(--text-color)';
    }

    function addTime(amount) {
        if (state.mode !== 'time') return;
        state.timeLeft += amount;
        updateTimerDisplay();
        const timerEl = DOM.timerVal;
        timerEl.style.color = '#33FF57';
        timerEl.style.transform = "scale(1.5)";
        setTimeout(() => {
            timerEl.style.color = state.timeLeft <= 10 ? '#ff4444' : 'var(--text-color)';
            timerEl.style.transform = "scale(1)";
        }, 400);
    }

    function spawnPieces() {
        DOM.pieces.innerHTML = '';
        let selectedShapes = [];
        let attempts = 0;
        while(selectedShapes.length < 3 && attempts < 100) {
            let pool;
            if (state.mode === 'expert') {
                const r = Math.random();
                if (r < 0.4) pool = SHAPES_SIMPLE;
                else if (r < 0.8) pool = SHAPES_COMPLEX;
                else pool = SHAPES_EXPERT_ONLY;
            } else {
                if (Math.random() < 0.75) pool = SHAPES_SIMPLE;
                else pool = SHAPES_COMPLEX;
            }
            let randIdx = Math.floor(Math.random() * pool.length);
            let candidateShape = pool[randIdx];
            let isDuplicate = false;
            for(let s of selectedShapes) {
                if(JSON.stringify(s) === JSON.stringify(candidateShape)) {
                    isDuplicate = true;
                    break;
                }
            }
            if(!isDuplicate) selectedShapes.push(candidateShape);
            attempts++;
        }
        selectedShapes.forEach(shape => createPieceWrapper(shape));
        setTimeout(checkGameOverCondition, 100);
    }

    function createPieceWrapper(shape) {
        const wrapper = document.createElement('div');
        wrapper.className = 'piece-wrapper';
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        const pieceEl = createPieceElement(shape, color);
        wrapper.appendChild(pieceEl);
        DOM.pieces.appendChild(wrapper);
        pieceEl.addEventListener('pointerdown', startDrag);
    }

    function createPieceElement(shape, color) {
        const rows = shape.length;
        const cols = shape[0].length;
        const el = document.createElement('div');
        el.className = 'draggable-piece';
        el.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
        el.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        el.dataset.shape = JSON.stringify(shape);
        el.dataset.color = color;
        shape.forEach(row => {
            row.forEach(val => {
                const cell = document.createElement('div');
                cell.className = 'piece-cell';
                if (val) {
                    cell.style.backgroundColor = color;
                    cell.style.boxShadow = "inset 0 1px 3px rgba(255,255,255,0.4)";
                } else cell.style.opacity = 0;
                el.appendChild(cell);
            });
        });
        return el;
    }

    function startDrag(e) {
        if (state.isPaused || state.bombMode) return;
        e.preventDefault();
        AudioSys.playPick();
        haptic(20);

        const piece = e.currentTarget;
        const rect = piece.getBoundingClientRect();
        
        dragData.active = true;
        dragData.element = piece;
        dragData.shape = JSON.parse(piece.dataset.shape);
        dragData.color = piece.dataset.color;
        
        DOM.board.classList.add('board-pulse');
        cacheGridPositions();

        dragData.offsetX = e.clientX - rect.left;
        dragData.offsetY = e.clientY - rect.top;
        
        piece.style.position = 'fixed';
        piece.style.zIndex = 1000;
        piece.style.width = rect.width + 'px';
        piece.style.height = rect.height + 'px';
        
        movePiece(e.clientX, e.clientY);
        piece.style.transform = "scale(1.1)";

        document.addEventListener('pointermove', onDrag);
        document.addEventListener('pointerup', endDrag);
    }

    function cacheGridPositions() {
        const cells = Array.from(document.querySelectorAll('.cell'));
        dragData.gridCache = cells.map(cell => {
            const rect = cell.getBoundingClientRect();
            return {
                r: parseInt(cell.dataset.r),
                c: parseInt(cell.dataset.c),
                left: rect.left,
                top: rect.top,
                right: rect.right,
                bottom: rect.bottom,
                width: rect.width,
                height: rect.height
            };
        });
        if(dragData.gridCache.length > 0) {
            dragData.cellW = dragData.gridCache[0].width;
            dragData.cellH = dragData.gridCache[0].height;
        }
    }

    function movePiece(clientX, clientY) {
        const isTouch = navigator.maxTouchPoints > 0;
        const liftY = isTouch ? 80 : 20; 
        const x = clientX - dragData.offsetX;
        const y = clientY - dragData.offsetY - liftY;
        dragData.element.style.left = x + 'px';
        dragData.element.style.top = y + 'px';
    }

    function onDrag(e) {
        if (!dragData.active) return;
        movePiece(e.clientX, e.clientY);
        const bestPos = findBestGridPositionV2();
        updatePreview(bestPos);
    }

    function endDrag(e) {
        if (!dragData.active) return;
        document.removeEventListener('pointermove', onDrag);
        document.removeEventListener('pointerup', endDrag);
        DOM.board.classList.remove('board-pulse');
        const bestPos = findBestGridPositionV2();
        let placed = false;
        if (bestPos) {
             if (canPlace(dragData.shape, bestPos.r, bestPos.c)) {
                 placePiece(dragData.shape, bestPos.r, bestPos.c, dragData.color);
                 dragData.element.remove();
                 placed = true;
                 handleTurnEnd();
             }
        }
        if (!placed) {
            dragData.element.style.position = 'static';
            dragData.element.style.transform = 'none';
            dragData.element.style.width = '';
            dragData.element.style.height = '';
            dragData.element.style.zIndex = '';
        }
        clearPreview();
        dragData.active = false;
        dragData.element = null;
        dragData.gridCache = null;
    }

    function findBestGridPositionV2() {
        if (!dragData.element || !dragData.gridCache) return null;
        const shape = dragData.shape;
        const sRows = shape.length;
        const sCols = shape[0].length;
        const cache = dragData.gridCache;
        const cellW = dragData.cellW;
        const cellH = dragData.cellH;
        const pRect = dragData.element.getBoundingClientRect();
        const pCenterX = pRect.left + pRect.width / 2;
        const pCenterY = pRect.top + pRect.height / 2;
        let bestR = -1;
        let bestC = -1;
        let minDistance = Infinity;
        const threshold = cellW * 2.5;

        for (let r = 0; r <= BOARD_SIZE - sRows; r++) {
            for (let c = 0; c <= BOARD_SIZE - sCols; c++) {
                const idxTL = r * 8 + c;
                const targetX = cache[idxTL].left + (sCols * cellW / 2);
                const targetY = cache[idxTL].top + (sRows * cellH / 2);
                const dist = Math.hypot(pCenterX - targetX, pCenterY - targetY);

                if (dist < minDistance) {
                    minDistance = dist;
                    bestR = r;
                    bestC = c;
                }
            }
        }
        if (minDistance < threshold && bestR !== -1) return { r: bestR, c: bestC };
        return null;
    }

    function canPlace(shape, r, c) {
        const rows = shape.length;
        const cols = shape[0].length;
        if (r < 0 || r + rows > BOARD_SIZE || c < 0 || c + cols > BOARD_SIZE) return false;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (shape[i][j] === 1) {
                    if (board[r + i][c + j] !== null) return false;
                }
            }
        }
        return true;
    }

    function placePiece(shape, r, c, color) {
        AudioSys.playDrop();
        haptic(40);
        const centerR = Math.floor(r + shape.length/2);
        const centerC = Math.floor(c + shape[0].length/2);
        const targetCell = document.querySelector(`.cell[data-r="${centerR}"][data-c="${centerC}"]`);
        if(targetCell) spawnParticles(targetCell);

        for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[i].length; j++) {
                if (shape[i][j] === 1) board[r + i][c + j] = color;
            }
        }
        updateBoardUI();
    }

    function updateBoardUI() {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => {
            const r = parseInt(cell.dataset.r);
            const c = parseInt(cell.dataset.c);
            const color = board[r][c];
            cell.style.backgroundColor = color ? color : '';
            if(color) cell.classList.add('filled');
            else cell.classList.remove('filled');
        });
    }

    function updatePreview(pos) {
        clearPreview();
        if (pos && canPlace(dragData.shape, pos.r, pos.c)) {
            const shape = dragData.shape;
            for (let i = 0; i < shape.length; i++) {
                for (let j = 0; j < shape[i].length; j++) {
                    if (shape[i][j] === 1) {
                        const cell = document.querySelector(`.cell[data-r="${pos.r+i}"][data-c="${pos.c+j}"]`);
                        if (cell) cell.classList.add('preview');
                    }
                }
            }
        }
    }

    function clearPreview() { document.querySelectorAll('.preview').forEach(el => el.classList.remove('preview')); }

    function handleTurnEnd() {
        const linesCleared = checkLinesAndScore();
        if (linesCleared === 0) {
            state.combo = 0;
            DOM.comboDisplay.style.opacity = '0';
        }
        if (DOM.pieces.children.length === 0 || 
           Array.from(DOM.pieces.children).every(c => c.children.length === 0)) {
            spawnPieces();
        } else checkGameOverCondition();
    }

    function checkLinesAndScore() {
        let rowsToClear = [];
        let colsToClear = [];

        for (let r = 0; r < BOARD_SIZE; r++) {
            if (board[r].every(val => val !== null)) rowsToClear.push(r);
        }
        for (let c = 0; c < BOARD_SIZE; c++) {
            let full = true;
            for (let r = 0; r < BOARD_SIZE; r++) {
                if (board[r][c] === null) { full = false; break; }
            }
            if (full) colsToClear.push(c);
        }

        const lines = rowsToClear.length + colsToClear.length;
        if (lines > 0) {
            AudioSys.playClear();
            haptic(100);
            DOM.board.classList.add('shake-effect');
            setTimeout(() => DOM.board.classList.remove('shake-effect'), 500);

            const cellsToClear = [];
            rowsToClear.forEach(r => {
                for(let c=0; c<BOARD_SIZE; c++) cellsToClear.push({r,c});
            });
            colsToClear.forEach(c => {
                for(let r=0; r<BOARD_SIZE; r++) cellsToClear.push({r,c});
            });

            cellsToClear.forEach(pos => {
                const cell = document.querySelector(`.cell[data-r="${pos.r}"][data-c="${pos.c}"]`);
                if(cell) {
                    cell.classList.add('clearing');
                    spawnParticles(cell);
                }
            });
            
            state.combo++;
            let comboMult = state.combo > 1 ? state.combo : 1;
            
            if (state.combo > 1) {
                showFloatingText(`COMBO x${state.combo}!`);
                DOM.comboDisplay.innerText = `x${state.combo} COMBO!`;
                DOM.comboDisplay.style.opacity = '1';
                AudioSys.playCombo(state.combo);
                checkAchievements('combo', state.combo);
            } else if (lines > 1) showFloatingText(`MULTI x${lines}!`);
            
            if (lines >= 4) checkAchievements('clear', lines);
            userStats.totalLines += lines;

            let earnedCoins = (lines * 2); 
            if (lines > 1) earnedCoins += lines * 2;
            if (state.combo > 1) earnedCoins += state.combo * 2;
            state.coins += earnedCoins;
            updateEconomyUI();

            setTimeout(() => {
                rowsToClear.forEach(r => board[r].fill(null));
                colsToClear.forEach(c => {
                    for(let r=0; r<BOARD_SIZE; r++) board[r][c] = null;
                });
                
                let points = lines * 10;
                if (lines > 1) points += (lines * 10);
                if (lines >= 3) points += 50; 
                points *= comboMult;

                if (state.mode === 'time') {
                    if (state.timeLeft < 5) checkAchievements('time_panic_clear');
                    addTime(lines * 5); 
                }

                updateScore(state.score + points);
                updateLevelUI(points); 
                updateBoardUI();
                
                document.querySelectorAll('.clearing').forEach(el => el.classList.remove('clearing'));
            }, 400); 
        }
        return lines;
    }

    function updateLevelUI(pointsGained = 0) {
        state.levelProgress += pointsGained;
        const xpNeeded = 200;
        
        while(state.levelProgress >= xpNeeded) {
            state.level++;
            state.levelProgress -= xpNeeded;
            
            // MODIFICA: Uso notifica invece di modal che blocca il gioco
            showNotification('‚¨ÜÔ∏è', 'LEVEL UP!', `Level ${state.level} (+50 ü™ô)`);
            
            AudioSys.playTone(800, 'square', 0.4, 0.2);
            state.coins += 50; 
        }

        userStats.currentLevel = state.level;
        userStats.currentXP = state.levelProgress;
        localStorage.setItem('bp_stats', JSON.stringify(userStats));
        updateEconomyUI();
        checkAchievements('level', state.level);

        DOM.levelLabel.innerText = `Lvl ${state.level}`;
        const pct = Math.min(100, (state.levelProgress / xpNeeded) * 100);
        DOM.levelBar.style.width = pct + '%';
    }

    function spawnParticles(element) {
        if(state.performanceMode) return;

        const rect = element.getBoundingClientRect();
        const centerX = rect.left + rect.width/2;
        const centerY = rect.top + rect.height/2;
        for(let i=0; i<8; i++) {
            const p = document.createElement('div');
            p.classList.add('particle');
            const angle = Math.random() * Math.PI * 2;
            const velocity = 50 + Math.random() * 100;
            const tx = Math.cos(angle) * velocity + 'px';
            const ty = Math.sin(angle) * velocity + 'px';
            p.style.setProperty('--tx', tx);
            p.style.setProperty('--ty', ty);
            p.style.left = centerX + 'px';
            p.style.top = centerY + 'px';
            p.style.width = (4 + Math.random() * 6) + 'px';
            p.style.height = p.style.width;
            p.style.backgroundColor = COLORS[Math.floor(Math.random() * COLORS.length)];
            DOM.particles.appendChild(p);
            setTimeout(() => p.remove(), 800);
        }
    }

    function showFloatingText(text) {
        const el = document.createElement('div');
        el.className = 'floating-text';
        el.innerText = text;
        const rect = DOM.board.getBoundingClientRect();
        el.style.top = (rect.top + rect.height / 2 - 20) + 'px';
        el.style.left = rect.left + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), state.performanceMode ? 500 : 1000);
    }

    function updateScore(val) {
        state.score = val;
        DOM.score.innerText = state.score;
        if (state.score > state.highScore) {
            state.highScore = state.score;
            DOM.highScore.innerText = state.highScore;
        }
        checkAchievements('score', state.score);
    }

    function checkGameOverCondition() {
        if (!state.isPlaying || state.isPaused) return;
        setTimeout(() => {
            const wrappers = document.querySelectorAll('.piece-wrapper');
            let hasPieces = false;
            let canMove = false;
            for (let w of wrappers) {
                const piece = w.querySelector('.draggable-piece');
                if (!piece) continue; 
                hasPieces = true;
                const shape = JSON.parse(piece.dataset.shape);
                for (let r = 0; r < BOARD_SIZE; r++) {
                    if (canMove) break;
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (canPlace(shape, r, c)) {
                            canMove = true;
                            break;
                        }
                    }
                }
                if (canMove) break;
            }
            if (hasPieces && !canMove) triggerGameOver('nomoves'); 
        }, 300);
    }

    function triggerGameOver(reason) {
        stopTimer();
        AudioSys.playGameOver();
        haptic(200);
        state.isPlaying = false;
        state.bombMode = false;
        DOM.board.classList.remove('bomb-active');
        
        userStats.lastScore = state.score;
        userStats.totalGames++;
        if(state.mode === 'classic' && state.score > userStats.classicBest) userStats.classicBest = state.score;
        if(state.mode === 'time' && state.score > userStats.timeBest) userStats.timeBest = state.score;
        if(state.mode === 'expert' && state.score > userStats.expertBest) userStats.expertBest = state.score;
        localStorage.setItem('bp_stats', JSON.stringify(userStats));

        let msg = "";
        const texts = TRANSLATIONS[state.language];

        if (reason === 'timeout') msg = texts.reason_timeout;
        else if (reason === 'nomoves') msg = texts.reason_nomoves;
        else msg = texts.reason_generic;
        
        DOM.reasonText.innerText = msg;
        DOM.finalScore.innerText = state.score;
        DOM.modal.classList.add('visible');
    }

    createBoardGrid(); 
</script>
</body>
</html>
