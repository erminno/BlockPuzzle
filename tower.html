<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Puzzle - Ultimate Gold</title>
    <style>
        :root {
            --bg-color: #121212;
            --board-bg: #1e1e24;
            --cell-empty: #2a2a35;
            /* Nuovi colori ORO */
            --text-color: #FFD700; 
            --text-secondary: #FFA500;
            --highlight: rgba(255, 215, 0, 0.2);
            --gap: 4px;
            --radius: 12px;
            --btn-radius: 50px;
            --danger: #ff4444;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 50%, #2a2a35 0%, #121212 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* --- PARTICELLE ED EFFETTI --- */
        #particles-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 150;
        }

        .particle {
            position: absolute;
            background: var(--text-color);
            border-radius: 50%;
            pointer-events: none;
            animation: particle-fade 0.8s forwards ease-out;
        }

        @keyframes particle-fade {
            0% { transform: translate(0,0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        .shake-effect {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        /* --- SCHERMATA INTRO (Caricamento Migliorato) --- */
        #intro-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--bg-color);
            z-index: 300;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease-in-out;
        }

        .loader-text-container {
            position: relative;
            margin-bottom: 20px;
            perspective: 500px;
        }

        #intro-text {
            font-size: 2.5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: transparent;
            background: linear-gradient(180deg, #FFD700 20%, #B8860B 80%);
            -webkit-background-clip: text;
            background-clip: text;
            text-align: center;
            opacity: 0;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
            transform-style: preserve-3d;
            transition: all 0.5s ease;
        }

        #intro-subtext {
            font-size: 1rem;
            color: #888;
            margin-top: 10px;
            opacity: 0;
            font-family: monospace;
            letter-spacing: 2px;
            transition: opacity 0.5s;
        }

        .intro-visible {
            opacity: 1 !important;
            transform: scale(1.1);
        }

        /* Loading Bar */
        .loading-bar-bg {
            width: 200px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 30px;
            overflow: hidden;
            position: relative;
        }

        .loading-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            box-shadow: 0 0 10px #FFD700;
            transition: width 0.3s ease-out;
        }

        /* --- MENU PRINCIPALE --- */
        #main-menu {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--bg-color);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #main-menu.hidden {
            transform: translateY(-100%) scale(0.9);
            opacity: 0;
            pointer-events: none;
        }

        .menu-title {
            font-size: 3.5rem;
            background: linear-gradient(to bottom, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 40px;
            text-transform: uppercase;
            letter-spacing: 2px;
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.4));
            text-align: center;
            font-weight: 800;
        }

        .menu-btn {
            background: linear-gradient(135deg, #FFD700, #ffb900);
            color: #1a1a2e;
            border: none;
            padding: 18px 45px;
            font-size: 1.3rem;
            border-radius: var(--btn-radius);
            cursor: pointer;
            margin: 10px;
            width: 85%;
            max-width: 320px;
            font-weight: 800;
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.3);
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 30px rgba(255, 215, 0, 0.4);
        }
        
        .menu-btn:active {
            transform: scale(0.95) translateY(0);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
        }

        .menu-btn.secondary {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--text-color);
            color: var(--text-color);
            box-shadow: none;
        }
        
        .menu-btn.secondary:hover {
            background: rgba(255, 215, 0, 0.1);
        }

        .menu-btn.expert {
            background: linear-gradient(135deg, #ff4e50, #f9d423);
            color: #1a1a2e;
        }

        /* Pulsante Settings nel Menu */
        .settings-btn-main {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--text-color);
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 201;
        }

        .settings-btn-main:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: rotate(45deg);
        }

        /* --- UI DI GIOCO --- */
        .top-bar {
            width: 90vw;
            max-width: 400px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .icon-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-color);
            font-size: 1.2rem;
            cursor: pointer;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            margin-right: 5px;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* NUOVA UI: Coins & Levels */
        .stats-row {
            width: 90vw;
            max-width: 400px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 5px;
        }

        .coin-display {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            padding: 5px 12px;
            border-radius: 20px;
            border: 1px solid var(--text-color);
            font-weight: bold;
            color: var(--text-color);
            gap: 5px;
        }

        .level-container {
            flex-grow: 1;
            margin-left: 15px;
            margin-right: 5px;
        }

        .level-text {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
        }

        .level-bar-bg {
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .level-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.5s ease-out;
        }

        .score-container {
            display: flex;
            gap: 8px;
            flex: 1;
            justify-content: flex-end;
        }

        .score-box {
            background: var(--board-bg);
            padding: 8px 15px;
            border-radius: 20px;
            text-align: center;
            min-width: 75px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            border: 1px solid rgba(255, 215, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .score-box.timer {
            border: 1px solid var(--text-color);
            background: rgba(255, 215, 0, 0.1);
            display: none; 
        }
        
        .score-box.timer.active {
            display: block;
        }

        .score-label {
            font-size: 0.6rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 2px;
        }

        .score-value {
            font-size: 1.2rem;
            font-weight: 800;
            color: white;
        }
        
        #score { color: var(--text-color); }

        /* Griglia di Gioco */
        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: var(--gap);
            background-color: var(--board-bg);
            padding: var(--gap);
            border-radius: 20px;
            width: 90vw;
            height: 90vw;
            max-width: 400px;
            max-height: 400px;
            position: relative;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 1px solid rgba(255, 215, 0, 0.1);
            transition: border-color 0.3s;
        }

        /* Effetto Bomba Attiva */
        #game-board.bomb-active {
            border: 2px solid #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
            cursor: crosshair;
        }
        
        #game-board.bomb-active .cell:hover {
            background-color: rgba(255, 68, 68, 0.3);
        }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 6px;
            width: 100%;
            height: 100%;
            transition: background-color 0.15s ease-out;
        }

        .cell.filled {
            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.2), inset 0 2px 5px rgba(255,255,255,0.4);
            position: relative;
        }
        
        .cell.filled::after {
            content: '';
            position: absolute;
            top: 2px; left: 2px;
            width: 40%; height: 40%;
            background: radial-gradient(circle at top left, rgba(255,255,255,0.6), transparent);
            border-radius: 4px;
        }

        .cell.preview {
            background-color: rgba(255, 215, 0, 0.2) !important;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.2);
            transform: scale(0.9);
            border-radius: 8px;
            border: 1px dashed rgba(255,215,0,0.5);
        }

        .cell.clearing {
            animation: vanish 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            z-index: 10;
        }

        @keyframes vanish {
            0% { 
                transform: scale(1); 
                filter: brightness(2) drop-shadow(0 0 10px gold); 
                background-color: #fff; 
            }
            100% { 
                transform: scale(0); 
                opacity: 0; 
            }
        }

        .floating-text {
            position: absolute;
            font-size: 2rem;
            font-weight: 900;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 160;
            width: 100%;
            text-align: center;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }

        /* --- POWER UPS --- */
        #powerups-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            width: 90vw;
            max-width: 400px;
        }

        .powerup-btn {
            background: linear-gradient(145deg, #2a2a35, #1e1e24);
            border: 1px solid #444;
            border-radius: 15px;
            padding: 8px 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #ccc;
            cursor: pointer;
            transition: all 0.2s;
            width: 100px;
            position: relative;
            overflow: hidden;
        }

        .powerup-btn:active {
            transform: scale(0.95);
        }

        .powerup-btn.affordable {
            border-color: var(--text-color);
            color: white;
            background: linear-gradient(145deg, #2a2a35, #252515);
        }

        .powerup-btn.active-mode {
            background: var(--text-color);
            color: #121212;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }

        .powerup-icon {
            font-size: 1.5rem;
            margin-bottom: 4px;
        }

        .powerup-cost {
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 3px;
            color: #888;
        }
        
        .affordable .powerup-cost {
            color: #FFD700;
        }

        #pieces-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 90vw;
            max-width: 400px;
            height: 120px; /* Reduced slightly to fit powerups */
            margin-top: 10px;
        }

        .piece-wrapper {
            width: 30%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s;
        }

        .draggable-piece {
            display: grid;
            gap: 2px;
            cursor: grab;
            transition: transform 0.1s;
            touch-action: none;
            padding: 10px;
        }
        
        .draggable-piece:active {
            cursor: grabbing;
        }

        .piece-cell {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            pointer-events: none;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.4);
        }

        /* Modals: Game Over, Pause, Settings */
        #game-over-modal, #pause-modal, #settings-modal {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(18, 18, 18, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 250; 
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }

        #game-over-modal.visible, #pause-modal.visible, #settings-modal.visible {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: #232323;
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            border: 1px solid rgba(255, 215, 0, 0.2);
            width: 85%;
            max-width: 350px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .visible .modal-content {
            transform: scale(1);
        }

        .modal-title {
            color: var(--text-color); 
            margin: 0 0 10px 0;
            font-size: 2.2rem;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            text-transform: uppercase;
        }
        
        #game-over-reason {
            color: #FFA500;
            font-size: 1.1rem;
            margin-bottom: 20px;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .modal-btn {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #1a1a2e;
            border: none;
            padding: 15px 35px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            width: 100%;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
            transition: transform 0.1s;
        }

        .modal-btn:active {
            transform: scale(0.96);
        }

        /* Settings Style */
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            width: 100%;
            color: #ccc;
            font-size: 1.1rem;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #FFD700;
        }
        input:checked + .slider:before {
            transform: translateX(22px);
            background-color: #1a1a2e;
        }

        /* Lang switch buttons */
        .lang-switch-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
            margin-bottom: 20px;
        }
        
        .lang-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            color: #888;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            font-size: 1.5rem;
        }
        
        .lang-btn.active {
            border-color: var(--text-color);
            color: white;
            background: rgba(255,215,0,0.1);
        }

        @media (min-width: 600px) {
            .piece-cell { width: 25px; height: 25px; }
            .menu-title { font-size: 4.5rem; }
        }
    </style>
</head>
<body>

    <!-- Particles Layer -->
    <div id="particles-container"></div>

    <!-- Intro Overlay -->
    <div id="intro-overlay">
        <div class="loader-text-container">
            <div id="intro-text"></div>
        </div>
        <div class="loading-bar-bg">
            <div class="loading-bar-fill" id="intro-bar"></div>
        </div>
        <div id="intro-subtext">Initializing...</div>
    </div>

    <!-- Menu Principale -->
    <div id="main-menu">
        <button class="settings-btn-main" onclick="openSettings()">‚öôÔ∏è</button>

        <h1 class="menu-title">Block<br>Puzzle</h1>
        <button class="menu-btn" onclick="startGame('classic')" data-lang-key="btn_classic">Classica</button>
        <button class="menu-btn secondary" onclick="startGame('time')" data-lang-key="btn_time">A Tempo ‚è±Ô∏è</button>
        <button class="menu-btn expert" onclick="startGame('expert')" data-lang-key="btn_expert">Esperto üî•</button>
    </div>

    <!-- UI Gioco -->
    <div class="top-bar">
        <div style="display:flex;">
            <button class="icon-btn" onclick="showMainMenu()">üè†</button>
            <button class="icon-btn" onclick="togglePause()">II</button>
        </div>
        <div class="score-container">
             <div class="score-box timer" id="timer-box">
                <div class="score-label" data-lang-key="label_time">Tempo</div>
                <div class="score-value" id="timer">60</div>
            </div>
            <div class="score-box">
                <div class="score-label" data-lang-key="label_score">Punteggio</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="score-box">
                <div class="score-label" data-lang-key="label_record">Record</div>
                <div class="score-value" id="high-score">0</div>
            </div>
        </div>
    </div>

    <!-- NUOVA SEZIONE: Stats, Coins, Level -->
    <div class="stats-row" id="stats-row" style="visibility: hidden;">
        <div class="coin-display">
            <span>ü™ô</span>
            <span id="coin-value">100</span>
        </div>
        <div class="level-container">
            <div class="level-text">
                <span id="level-label">Lvl 1</span>
                <span id="combo-display" style="color:#FFD700; font-weight:bold; opacity:0;">x2 COMBO!</span>
            </div>
            <div class="level-bar-bg">
                <div class="level-bar-fill" id="level-bar"></div>
            </div>
        </div>
    </div>

    <div id="game-board" onclick="handleBoardClick(event)">
        <!-- Generato via JS -->
    </div>

    <!-- NUOVA SEZIONE: Power Ups -->
    <div id="powerups-container" style="visibility: hidden;">
        <button class="powerup-btn" id="btn-rotate" onclick="usePowerup('rotate')">
            <div class="powerup-icon">üîÑ</div>
            <div class="powerup-cost">20 ü™ô</div>
        </button>
        <button class="powerup-btn" id="btn-bomb" onclick="usePowerup('bomb')">
            <div class="powerup-icon">üí£</div>
            <div class="powerup-cost">50 ü™ô</div>
        </button>
    </div>

    <div id="pieces-container">
        <!-- Pezzi generati qui -->
    </div>

    <!-- Modal Game Over -->
    <div id="game-over-modal">
        <div class="modal-content">
            <h1 class="modal-title" data-lang-key="modal_gameover">Game Over!</h1>
            <div id="game-over-reason"></div>
            
            <p style="color:#889; margin-bottom: 5px; font-size: 0.9rem;" data-lang-key="label_final_score">Punteggio Finale</p>
            <div id="final-score" style="color:white; font-size: 3rem; font-weight:800; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255,215,0,0.5);">0</div>
            
            <button class="modal-btn" onclick="restartGame()" data-lang-key="btn_retry">Riprova</button>
            <button class="modal-btn" style="background:transparent; border:2px solid #555; color: #aaa; margin-top:10px; box-shadow:none;" onclick="showMainMenu()" data-lang-key="btn_mainmenu">Menu Principale</button>
        </div>
    </div>

    <!-- Modal Pausa -->
    <div id="pause-modal">
        <div class="modal-content">
            <h1 class="modal-title" data-lang-key="modal_pause">Pausa</h1>
            <button class="modal-btn" onclick="togglePause()" data-lang-key="btn_resume">Riprendi</button>
            <button class="modal-btn" style="background:transparent; border:2px solid #555; color: #aaa; margin-top:10px; box-shadow:none;" onclick="showMainMenu()" data-lang-key="btn_exit">Esci</button>
        </div>
    </div>

    <!-- Modal Settings -->
    <div id="settings-modal">
        <div class="modal-content">
            <h1 class="modal-title" data-lang-key="modal_settings">Impostazioni</h1>
            
            <p style="color:#aaa; margin-bottom:5px;" data-lang-key="label_language">Lingua / Language</p>
            <div class="lang-switch-container">
                <button class="lang-btn active" id="btn-lang-it" onclick="setLanguage('it')">üáÆüáπ</button>
                <button class="lang-btn" id="btn-lang-en" onclick="setLanguage('en')">üá¨üáß</button>
            </div>

            <!-- Nuove opzioni Audio/Vibrazione -->
            <div class="setting-row">
                <span data-lang-key="opt_sound">Suoni</span>
                <label class="switch">
                    <input type="checkbox" id="chk-sound" checked onchange="toggleSound(this.checked)">
                    <span class="slider"></span>
                </label>
            </div>
            
            <div class="setting-row">
                <span data-lang-key="opt_haptics">Vibrazione</span>
                <label class="switch">
                    <input type="checkbox" id="chk-haptics" checked onchange="toggleHaptics(this.checked)">
                    <span class="slider"></span>
                </label>
            </div>
            
            <button class="modal-btn" style="margin-top:30px;" onclick="closeSettings()" data-lang-key="btn_close">Chiudi</button>
        </div>
    </div>

<script>
    // --- Configurazione e Stato ---
    const BOARD_SIZE = 8;
    const board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
    
    // TRADUZIONI
    const TRANSLATIONS = {
        it: {
            btn_classic: "Classica",
            btn_time: "A Tempo ‚è±Ô∏è",
            btn_expert: "Esperto üî•",
            label_time: "Tempo",
            label_score: "Punteggio",
            label_record: "Record",
            modal_gameover: "Game Over!",
            label_final_score: "Punteggio Finale",
            btn_retry: "Riprova",
            btn_mainmenu: "Menu Principale",
            modal_pause: "Pausa",
            btn_resume: "Riprendi",
            btn_exit: "Esci",
            modal_settings: "Impostazioni",
            label_language: "Lingua / Language",
            btn_close: "Chiudi",
            opt_sound: "Suoni",
            opt_haptics: "Vibrazione",
            reason_timeout: "Tempo Scaduto! ‚è≥",
            reason_nomoves: "Nessuno spazio per i blocchi! üß±",
            reason_generic: "Partita Finita"
        },
        en: {
            btn_classic: "Classic",
            btn_time: "Time Mode ‚è±Ô∏è",
            btn_expert: "Expert üî•",
            label_time: "Time",
            label_score: "Score",
            label_record: "Best",
            modal_gameover: "Game Over!",
            label_final_score: "Final Score",
            btn_retry: "Retry",
            btn_mainmenu: "Main Menu",
            modal_pause: "Paused",
            btn_resume: "Resume",
            btn_exit: "Quit",
            modal_settings: "Settings",
            label_language: "Language / Lingua",
            btn_close: "Close",
            opt_sound: "Sounds",
            opt_haptics: "Haptics",
            reason_timeout: "Time's Up! ‚è≥",
            reason_nomoves: "No space for blocks! üß±",
            reason_generic: "Game Over"
        }
    };

    let state = {
        score: 0,
        highScore: localStorage.getItem('blockPuzzleHighScore') || 0,
        coins: parseInt(localStorage.getItem('blockPuzzleCoins') || 100), // NOVITA
        level: 1, // NOVITA
        levelProgress: 0,
        combo: 0, // NOVITA
        mode: 'classic', 
        timeLeft: 60,
        isPlaying: false,
        isPaused: false,
        timerInterval: null,
        language: 'it',
        soundEnabled: true,
        hapticsEnabled: true,
        bombMode: false // NOVITA
    };

    // --- AUDIO SYSTEM (SINTETIZZATORE) ---
    const AudioSys = {
        ctx: null,
        init: function() {
            if (!this.ctx && (window.AudioContext || window.webkitAudioContext)) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
        },
        playTone: function(freq, type, duration, vol=0.1) {
            if (!state.soundEnabled || !this.ctx) return;
            // Resume context if suspended (browser policy)
            if (this.ctx.state === 'suspended') this.ctx.resume();

            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        playClick: function() { this.playTone(600, 'sine', 0.1, 0.05); },
        playPick: function() { this.playTone(400, 'triangle', 0.1, 0.1); },
        playDrop: function() { this.playTone(200, 'sawtooth', 0.15, 0.1); },
        playPowerup: function() { 
            this.playTone(600, 'sine', 0.1, 0.2); 
            setTimeout(()=>this.playTone(900, 'square', 0.2, 0.1), 100);
        },
        playExplosion: function() {
             this.playTone(100, 'sawtooth', 0.3, 0.4); 
             setTimeout(()=>this.playTone(50, 'square', 0.4, 0.3), 50);
        },
        playClear: function() {
            // Arpeggio magico
            setTimeout(() => this.playTone(500, 'sine', 0.3, 0.1), 0);
            setTimeout(() => this.playTone(750, 'sine', 0.3, 0.1), 100);
            setTimeout(() => this.playTone(1000, 'sine', 0.4, 0.1), 200);
        },
        playCombo: function(mult) {
            let base = 600 + (mult * 100);
            this.playTone(base, 'square', 0.1, 0.1);
            setTimeout(()=>this.playTone(base + 200, 'square', 0.2, 0.1), 100);
        },
        playGameOver: function() {
            setTimeout(() => this.playTone(300, 'sawtooth', 0.5, 0.2), 0);
            setTimeout(() => this.playTone(200, 'sawtooth', 0.5, 0.2), 400);
            setTimeout(() => this.playTone(100, 'sawtooth', 0.8, 0.2), 800);
        }
    };

    function haptic(ms) {
        if (state.hapticsEnabled && navigator.vibrate) {
            navigator.vibrate(ms);
        }
    }

    // Variabili Drag & Drop
    let dragData = {
        active: false,
        element: null,
        shape: null,
        color: null,
        offsetX: 0,
        offsetY: 0,
        gridCache: null 
    };
    
    // Riferimenti DOM
    const DOM = {
        board: document.getElementById('game-board'),
        pieces: document.getElementById('pieces-container'),
        score: document.getElementById('score'),
        highScore: document.getElementById('high-score'),
        modal: document.getElementById('game-over-modal'),
        pauseModal: document.getElementById('pause-modal'),
        settingsModal: document.getElementById('settings-modal'),
        finalScore: document.getElementById('final-score'),
        reasonText: document.getElementById('game-over-reason'), 
        menu: document.getElementById('main-menu'),
        timerBox: document.getElementById('timer-box'),
        timerVal: document.getElementById('timer'),
        // Intro
        introOverlay: document.getElementById('intro-overlay'),
        introText: document.getElementById('intro-text'),
        introSub: document.getElementById('intro-subtext'),
        introBar: document.getElementById('intro-bar'),
        // Particle Container
        particles: document.getElementById('particles-container'),
        // NOVITA UI
        statsRow: document.getElementById('stats-row'),
        powerupsContainer: document.getElementById('powerups-container'),
        coinValue: document.getElementById('coin-value'),
        levelLabel: document.getElementById('level-label'),
        levelBar: document.getElementById('level-bar'),
        comboDisplay: document.getElementById('combo-display'),
        btnRotate: document.getElementById('btn-rotate'),
        btnBomb: document.getElementById('btn-bomb')
    };

    // --- SEQUENZA INTRO AVANZATA ---
    window.onload = function() {
        runIntroSequence();
        
        // Load settings from localstorage
        const savedSound = localStorage.getItem('bp_sound');
        const savedHaptics = localStorage.getItem('bp_haptics');
        if(savedSound !== null) {
            state.soundEnabled = (savedSound === 'true');
            document.getElementById('chk-sound').checked = state.soundEnabled;
        }
        if(savedHaptics !== null) {
            state.hapticsEnabled = (savedHaptics === 'true');
            document.getElementById('chk-haptics').checked = state.hapticsEnabled;
        }
        updateEconomyUI();
    };

    function runIntroSequence() {
        const phrases = ["Made by Minno", "Forging Blocks...", "Polishing Gold...", "Ultimate Experience"];
        let step = 0;

        // Start bar animation
        setTimeout(() => DOM.introBar.style.width = '100%', 100);

        function nextPhrase() {
            if (step >= phrases.length) {
                // Finish
                DOM.introOverlay.style.opacity = '0';
                setTimeout(() => {
                    DOM.introOverlay.style.display = 'none';
                    AudioSys.init(); // Pre-init audio
                }, 800);
                return;
            }

            DOM.introText.innerText = phrases[step];
            DOM.introText.classList.add('intro-visible');
            DOM.introSub.style.opacity = '1';

            // Speciale per l'ultima frase
            if (step === phrases.length - 1) {
                DOM.introText.innerHTML = "Block Puzzle<br>Ultimate Gold";
            }

            setTimeout(() => {
                if (step < phrases.length - 1) {
                    DOM.introText.classList.remove('intro-visible');
                    DOM.introSub.style.opacity = '0';
                }
                step++;
                setTimeout(nextPhrase, 500);
            }, 1200);
        }

        nextPhrase();
    }

    // Colori
    const COLORS = [
        '#FF5733', '#33FF57', '#3357FF', '#F333FF', '#00E5FF', '#FFD700', '#FF8C33'
    ];

    const SHAPES = [
        [[1]], 
        [[1,1]], [[1,1,1]], [[1,1,1,1]], [[1,1,1,1,1]],
        [[1],[1]], [[1],[1],[1]], [[1],[1],[1],[1]], [[1],[1],[1],[1],[1]],
        [[1,1],[1,1]], [[1,1,1],[1,1,1]], 
        [[1,0],[1,1]], [[0,1],[1,1]], [[1,1],[1,0]], [[1,1],[0,1]],
        [[1,1,1],[0,1,0]], [[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[0,1],[1,1],[0,1]],
        [[1,0,0],[1,0,0],[1,1,1]], [[0,0,1],[0,0,1],[1,1,1]]
    ];

    const EXPERT_SHAPES = [
        [[1,0,1],[1,1,1]], [[1,1,1],[1,0,1]], 
        [[0,1,0],[1,1,1],[0,1,0]], 
        [[1,1,1],[0,1,0],[0,1,0]], 
        [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], 
        [[1,0,0],[1,0,0],[1,1,1]], [[1,1,1],[0,0,1],[0,0,1]], 
        [[1,1],[1,1]] 
    ];

    DOM.highScore.innerText = state.highScore;

    // --- Gestione Impostazioni ---
    function setLanguage(lang) {
        state.language = lang;
        AudioSys.playClick();
        
        const texts = TRANSLATIONS[lang];
        document.querySelectorAll('[data-lang-key]').forEach(el => {
            const key = el.getAttribute('data-lang-key');
            if (texts[key]) el.innerText = texts[key];
        });

        document.getElementById('btn-lang-it').classList.toggle('active', lang === 'it');
        document.getElementById('btn-lang-en').classList.toggle('active', lang === 'en');
    }

    function toggleSound(val) {
        state.soundEnabled = val;
        localStorage.setItem('bp_sound', val);
        if(val) AudioSys.playClick();
    }

    function toggleHaptics(val) {
        state.hapticsEnabled = val;
        localStorage.setItem('bp_haptics', val);
        if(val) haptic(50);
    }

    function openSettings() {
        AudioSys.playClick();
        DOM.settingsModal.classList.add('visible');
    }
    
    function closeSettings() {
        AudioSys.playClick();
        DOM.settingsModal.classList.remove('visible');
    }

    // --- Gestione Menu e Flusso ---
    function showMainMenu() {
        AudioSys.playClick();
        stopTimer();
        DOM.modal.classList.remove('visible');
        DOM.pauseModal.classList.remove('visible');
        DOM.menu.classList.remove('hidden');
        DOM.statsRow.style.visibility = 'hidden';
        DOM.powerupsContainer.style.visibility = 'hidden';
        state.isPlaying = false;
        state.isPaused = false;
    }

    function startGame(mode) {
        // Init audio context on first user interaction in game
        AudioSys.init();
        AudioSys.playClick();

        state.mode = mode;
        state.score = 0;
        state.level = 1;
        state.levelProgress = 0;
        state.combo = 0;
        state.isPlaying = true;
        state.isPaused = false;
        state.bombMode = false;
        
        DOM.settingsModal.classList.remove('visible'); 
        DOM.statsRow.style.visibility = 'visible';
        DOM.powerupsContainer.style.visibility = 'visible';
        DOM.board.classList.remove('bomb-active');
        DOM.btnBomb.classList.remove('active-mode');

        if (mode === 'time') {
            state.timeLeft = 60;
            DOM.timerBox.classList.add('active');
            updateTimerDisplay();
            startTimer();
        } else {
            DOM.timerBox.classList.remove('active');
        }

        updateScore(0);
        updateLevelUI();
        updateEconomyUI();
        createBoardGrid();
        for(let r=0; r<BOARD_SIZE; r++) board[r].fill(null);
        updateBoardUI(); 

        spawnPieces();
        DOM.menu.classList.add('hidden');
        DOM.modal.classList.remove('visible');
        DOM.pauseModal.classList.remove('visible');
    }

    function restartGame() {
        startGame(state.mode);
    }

    function togglePause() {
        AudioSys.playClick();
        if (!state.isPlaying) return;
        state.isPaused = !state.isPaused;
        
        if (state.isPaused) {
            stopTimer();
            DOM.pauseModal.classList.add('visible');
        } else {
            if (state.mode === 'time') startTimer();
            DOM.pauseModal.classList.remove('visible');
        }
    }

    function createBoardGrid() {
        DOM.board.innerHTML = '';
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.r = r;
                cell.dataset.c = c;
                DOM.board.appendChild(cell);
            }
        }
    }

    // --- NOVITA: LOGICA ECONOMIA E POWERUPS ---
    function updateEconomyUI() {
        DOM.coinValue.innerText = state.coins;
        localStorage.setItem('blockPuzzleCoins', state.coins);
        
        // Update bottoni
        DOM.btnRotate.classList.toggle('affordable', state.coins >= 20);
        DOM.btnBomb.classList.toggle('affordable', state.coins >= 50);
    }

    function usePowerup(type) {
        if(!state.isPlaying || state.isPaused) return;

        if (type === 'rotate') {
            if (state.coins >= 20) {
                state.coins -= 20;
                AudioSys.playPowerup();
                rotateAllPieces();
                updateEconomyUI();
                spawnParticles(DOM.btnRotate); 
            } else {
                AudioSys.playTone(150, 'sawtooth', 0.2); // Error sound
                DOM.btnRotate.classList.add('shake-effect');
                setTimeout(()=>DOM.btnRotate.classList.remove('shake-effect'), 400);
            }
        } else if (type === 'bomb') {
            if (state.coins >= 50) {
                if (state.bombMode) {
                    // Cancel
                    state.bombMode = false;
                    DOM.board.classList.remove('bomb-active');
                    DOM.btnBomb.classList.remove('active-mode');
                } else {
                    // Activate
                    state.bombMode = true;
                    DOM.board.classList.add('bomb-active');
                    DOM.btnBomb.classList.add('active-mode');
                    showFloatingText("BOMB MODE!");
                }
            } else {
                AudioSys.playTone(150, 'sawtooth', 0.2);
                DOM.btnBomb.classList.add('shake-effect');
                setTimeout(()=>DOM.btnBomb.classList.remove('shake-effect'), 400);
            }
        }
    }

    function rotateAllPieces() {
        const wrappers = document.querySelectorAll('.piece-wrapper');
        wrappers.forEach(w => {
            const piece = w.querySelector('.draggable-piece');
            if (piece) {
                const oldShape = JSON.parse(piece.dataset.shape);
                const color = piece.dataset.color;
                
                // Ruota Matrice 90 gradi orario
                const rows = oldShape.length;
                const cols = oldShape[0].length;
                let newShape = Array(cols).fill().map(() => Array(rows).fill(0));
                
                for(let i=0; i<rows; i++) {
                    for(let j=0; j<cols; j++) {
                        newShape[j][rows-1-i] = oldShape[i][j];
                    }
                }
                
                // Ricrea elemento
                w.innerHTML = '';
                const newEl = createPieceElement(newShape, color);
                w.appendChild(newEl);
                newEl.addEventListener('pointerdown', startDrag);
                
                // Animazione
                newEl.style.transform = "rotate(90deg) scale(0)";
                setTimeout(()=> newEl.style.transform = "rotate(0deg) scale(1)", 50);
            }
        });
    }

    function handleBoardClick(e) {
        if (!state.bombMode) return;
        
        const cell = e.target.closest('.cell');
        if (!cell) return;

        const r = parseInt(cell.dataset.r);
        const c = parseInt(cell.dataset.c);

        // Explode 3x3
        AudioSys.playExplosion();
        haptic(100);
        
        let cleared = false;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const tr = r + i;
                const tc = c + j;
                if(tr>=0 && tr<BOARD_SIZE && tc>=0 && tc<BOARD_SIZE) {
                    if (board[tr][tc] !== null) {
                        board[tr][tc] = null;
                        cleared = true;
                        // Visuals
                        const tCell = document.querySelector(`.cell[data-r="${tr}"][data-c="${tc}"]`);
                        if(tCell) {
                            tCell.classList.add('clearing');
                            spawnParticles(tCell);
                        }
                    }
                }
            }
        }
        
        setTimeout(() => {
            updateBoardUI();
            document.querySelectorAll('.clearing').forEach(el => el.classList.remove('clearing'));
        }, 300);

        // Pay cost and reset mode
        state.coins -= 50;
        updateEconomyUI();
        state.bombMode = false;
        DOM.board.classList.remove('bomb-active');
        DOM.btnBomb.classList.remove('active-mode');
    }

    // --- Timer ---
    function startTimer() {
        stopTimer();
        state.timerInterval = setInterval(() => {
            if (state.isPaused) return;
            state.timeLeft--;
            updateTimerDisplay();
            if (state.timeLeft <= 0) {
                stopTimer();
                triggerGameOver('timeout');
            }
        }, 1000);
    }

    function stopTimer() {
        if (state.timerInterval) clearInterval(state.timerInterval);
    }

    function updateTimerDisplay() {
        DOM.timerVal.innerText = state.timeLeft;
        if (state.timeLeft <= 10) DOM.timerVal.style.color = '#ff4444';
        else DOM.timerVal.style.color = 'var(--text-color)';
    }

    function addTime(amount) {
        if (state.mode !== 'time') return;
        state.timeLeft += amount;
        updateTimerDisplay();
        
        const timerEl = DOM.timerVal;
        timerEl.style.color = '#33FF57';
        timerEl.style.transform = "scale(1.5)";
        setTimeout(() => {
            timerEl.style.color = state.timeLeft <= 10 ? '#ff4444' : 'var(--text-color)';
            timerEl.style.transform = "scale(1)";
        }, 400);
    }

    // --- Gestione Pezzi ---
    function spawnPieces() {
        DOM.pieces.innerHTML = '';
        for (let i = 0; i < 3; i++) {
            createPieceWrapper();
        }
        checkGameOverCondition();
    }

    function createPieceWrapper() {
        const wrapper = document.createElement('div');
        wrapper.className = 'piece-wrapper';
        
        let shapePool = SHAPES;
        if (state.mode === 'expert') {
            if (Math.random() < 0.4) {
                shapePool = EXPERT_SHAPES;
            }
        }

        const shapeIdx = Math.floor(Math.random() * shapePool.length);
        const shape = shapePool[shapeIdx];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];

        const pieceEl = createPieceElement(shape, color);
        wrapper.appendChild(pieceEl);
        DOM.pieces.appendChild(wrapper);

        pieceEl.addEventListener('pointerdown', startDrag);
    }

    function createPieceElement(shape, color) {
        const rows = shape.length;
        const cols = shape[0].length;
        const el = document.createElement('div');
        el.className = 'draggable-piece';
        el.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
        el.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        
        el.dataset.shape = JSON.stringify(shape);
        el.dataset.color = color;

        shape.forEach(row => {
            row.forEach(val => {
                const cell = document.createElement('div');
                cell.className = 'piece-cell';
                if (val) {
                    cell.style.backgroundColor = color;
                    cell.style.boxShadow = "inset 0 1px 3px rgba(255,255,255,0.4)";
                } else {
                    cell.style.opacity = 0;
                }
                el.appendChild(cell);
            });
        });

        return el;
    }

    // --- Logica Drag & Drop ---
    function startDrag(e) {
        if (state.isPaused || state.bombMode) return; // Disable drag during bomb mode
        e.preventDefault();
        
        // Pick sound
        AudioSys.playPick();
        haptic(20);

        const piece = e.currentTarget;
        const rect = piece.getBoundingClientRect();
        
        dragData.active = true;
        dragData.element = piece;
        dragData.shape = JSON.parse(piece.dataset.shape);
        dragData.color = piece.dataset.color;
        
        cacheGridPositions();

        dragData.offsetX = e.clientX - rect.left;
        dragData.offsetY = e.clientY - rect.top;
        
        piece.style.position = 'fixed';
        piece.style.zIndex = 1000;
        piece.style.width = rect.width + 'px';
        piece.style.height = rect.height + 'px';
        
        movePiece(e.clientX, e.clientY);
        piece.style.transform = "scale(1.1)";

        document.addEventListener('pointermove', onDrag);
        document.addEventListener('pointerup', endDrag);
    }

    function cacheGridPositions() {
        const cells = Array.from(document.querySelectorAll('.cell'));
        dragData.gridCache = cells.map(cell => {
            const rect = cell.getBoundingClientRect();
            return {
                r: parseInt(cell.dataset.r),
                c: parseInt(cell.dataset.c),
                left: rect.left,
                top: rect.top,
                right: rect.right,
                bottom: rect.bottom,
                width: rect.width,
                height: rect.height
            };
        });
        
        if(dragData.gridCache.length > 0) {
            dragData.cellW = dragData.gridCache[0].width;
            dragData.cellH = dragData.gridCache[0].height;
        }
    }

    function movePiece(clientX, clientY) {
        const isTouch = navigator.maxTouchPoints > 0;
        const liftY = isTouch ? 80 : 20; 
        
        const x = clientX - dragData.offsetX;
        const y = clientY - dragData.offsetY - liftY;
        
        dragData.element.style.left = x + 'px';
        dragData.element.style.top = y + 'px';
    }

    function onDrag(e) {
        if (!dragData.active) return;
        movePiece(e.clientX, e.clientY);
        const bestPos = findBestGridPositionV2();
        updatePreview(bestPos);
    }

    function endDrag(e) {
        if (!dragData.active) return;
        
        document.removeEventListener('pointermove', onDrag);
        document.removeEventListener('pointerup', endDrag);

        const bestPos = findBestGridPositionV2();
        let placed = false;

        if (bestPos) {
             if (canPlace(dragData.shape, bestPos.r, bestPos.c)) {
                 placePiece(dragData.shape, bestPos.r, bestPos.c, dragData.color);
                 dragData.element.remove();
                 placed = true;
                 handleTurnEnd();
             }
        }

        if (!placed) {
            dragData.element.style.position = 'static';
            dragData.element.style.transform = 'none';
            dragData.element.style.width = '';
            dragData.element.style.height = '';
            dragData.element.style.zIndex = '';
        }

        clearPreview();
        dragData.active = false;
        dragData.element = null;
        dragData.gridCache = null;
    }

    function findBestGridPositionV2() {
        if (!dragData.element || !dragData.gridCache) return null;

        const shape = dragData.shape;
        const sRows = shape.length;
        const sCols = shape[0].length;
        const cache = dragData.gridCache;
        const cellW = dragData.cellW;
        const cellH = dragData.cellH;

        const pRect = dragData.element.getBoundingClientRect();
        const pCenterX = pRect.left + pRect.width / 2;
        const pCenterY = pRect.top + pRect.height / 2;

        let bestR = -1;
        let bestC = -1;
        let minDistance = Infinity;
        const threshold = cellW * 2.5;

        for (let r = 0; r <= BOARD_SIZE - sRows; r++) {
            for (let c = 0; c <= BOARD_SIZE - sCols; c++) {
                const idxTL = r * 8 + c;
                const targetX = cache[idxTL].left + (sCols * cellW / 2);
                const targetY = cache[idxTL].top + (sRows * cellH / 2);
                const dist = Math.hypot(pCenterX - targetX, pCenterY - targetY);

                if (dist < minDistance) {
                    minDistance = dist;
                    bestR = r;
                    bestC = c;
                }
            }
        }

        if (minDistance < threshold && bestR !== -1) {
            return { r: bestR, c: bestC };
        }
        return null;
    }

    function canPlace(shape, r, c) {
        for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[i].length; j++) {
                if (shape[i][j] === 1) {
                    const checkR = r + i;
                    const checkC = c + j;
                    if (checkR < 0 || checkR >= BOARD_SIZE || checkC < 0 || checkC >= BOARD_SIZE) return false;
                    if (board[checkR][checkC] !== null) return false;
                }
            }
        }
        return true;
    }

    function placePiece(shape, r, c, color) {
        AudioSys.playDrop();
        haptic(40);
        
        for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[i].length; j++) {
                if (shape[i][j] === 1) {
                    board[r + i][c + j] = color;
                }
            }
        }
        updateBoardUI();
    }

    function updateBoardUI() {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => {
            const r = parseInt(cell.dataset.r);
            const c = parseInt(cell.dataset.c);
            const color = board[r][c];
            
            cell.style.backgroundColor = color ? color : '';
            if(color) cell.classList.add('filled');
            else cell.classList.remove('filled');
        });
    }

    function updatePreview(pos) {
        clearPreview();
        if (pos && canPlace(dragData.shape, pos.r, pos.c)) {
            const shape = dragData.shape;
            for (let i = 0; i < shape.length; i++) {
                for (let j = 0; j < shape[i].length; j++) {
                    if (shape[i][j] === 1) {
                        const cell = document.querySelector(`.cell[data-r="${pos.r+i}"][data-c="${pos.c+j}"]`);
                        if (cell) cell.classList.add('preview');
                    }
                }
            }
        }
    }

    function clearPreview() {
        document.querySelectorAll('.preview').forEach(el => el.classList.remove('preview'));
    }

    function handleTurnEnd() {
        const linesCleared = checkLinesAndScore();
        
        // Reset combo if no lines cleared
        if (linesCleared === 0) {
            state.combo = 0;
            DOM.comboDisplay.style.opacity = '0';
        }

        if (DOM.pieces.children.length === 0 || 
           Array.from(DOM.pieces.children).every(c => c.children.length === 0)) {
            spawnPieces();
        } else {
            checkGameOverCondition();
        }
    }

    function checkLinesAndScore() {
        let rowsToClear = [];
        let colsToClear = [];

        for (let r = 0; r < BOARD_SIZE; r++) {
            if (board[r].every(val => val !== null)) rowsToClear.push(r);
        }
        for (let c = 0; c < BOARD_SIZE; c++) {
            let full = true;
            for (let r = 0; r < BOARD_SIZE; r++) {
                if (board[r][c] === null) { full = false; break; }
            }
            if (full) colsToClear.push(c);
        }

        const lines = rowsToClear.length + colsToClear.length;
        if (lines > 0) {
            // FX
            AudioSys.playClear();
            haptic(100);
            DOM.board.classList.add('shake-effect');
            setTimeout(() => DOM.board.classList.remove('shake-effect'), 500);

            const cellsToClear = [];
            rowsToClear.forEach(r => {
                for(let c=0; c<BOARD_SIZE; c++) cellsToClear.push({r,c});
            });
            colsToClear.forEach(c => {
                for(let r=0; r<BOARD_SIZE; r++) cellsToClear.push({r,c});
            });

            // Particles & Visuals
            cellsToClear.forEach(pos => {
                const cell = document.querySelector(`.cell[data-r="${pos.r}"][data-c="${pos.c}"]`);
                if(cell) {
                    cell.classList.add('clearing');
                    spawnParticles(cell);
                }
            });
            
            // Logic Combo & Coins
            state.combo++;
            let comboMult = state.combo > 1 ? state.combo : 1;
            
            if (state.combo > 1) {
                showFloatingText(`COMBO x${state.combo}!`);
                DOM.comboDisplay.innerText = `x${state.combo} COMBO!`;
                DOM.comboDisplay.style.opacity = '1';
                AudioSys.playCombo(state.combo);
            } else if (lines > 1) {
                showFloatingText(`MULTI x${lines}!`);
            }

            // Coin calculation: (lines * 5) + (lines > 1 bonus) + (combo bonus)
            let earnedCoins = (lines * 2); 
            if (lines > 1) earnedCoins += lines * 2;
            if (state.combo > 1) earnedCoins += state.combo * 2;
            
            state.coins += earnedCoins;
            updateEconomyUI();

            setTimeout(() => {
                rowsToClear.forEach(r => board[r].fill(null));
                colsToClear.forEach(c => {
                    for(let r=0; r<BOARD_SIZE; r++) board[r][c] = null;
                });
                
                let points = lines * 10;
                if (lines > 1) points += (lines * 10);
                if (lines >= 3) points += 50; 
                
                points *= comboMult;

                if (state.mode === 'time') {
                    addTime(lines * 5); 
                }

                updateScore(state.score + points);
                updateLevelUI(); // Check level up
                updateBoardUI();
                
                document.querySelectorAll('.clearing').forEach(el => el.classList.remove('clearing'));
            }, 400); 
        }
        
        return lines;
    }

    function updateLevelUI() {
        const xpNeeded = state.level * 200;
        state.levelProgress = state.score % xpNeeded;
        
        // Simple Level Up logic
        const currentLevelCalc = Math.floor(state.score / 200) + 1;
        if(currentLevelCalc > state.level) {
            state.level = currentLevelCalc;
            showFloatingText("LEVEL UP!");
            AudioSys.playTone(800, 'square', 0.4, 0.2);
            // Bonus coins per level up
            state.coins += 20; 
            updateEconomyUI();
        }

        DOM.levelLabel.innerText = `Lvl ${state.level}`;
        const pct = Math.min(100, (state.score - ((state.level-1)*200)) / 200 * 100);
        DOM.levelBar.style.width = pct + '%';
    }

    function spawnParticles(element) {
        const rect = element.getBoundingClientRect();
        const centerX = rect.left + rect.width/2;
        const centerY = rect.top + rect.height/2;
        
        for(let i=0; i<8; i++) { // 8 particelle per blocco
            const p = document.createElement('div');
            p.classList.add('particle');
            
            // Random direction
            const angle = Math.random() * Math.PI * 2;
            const velocity = 50 + Math.random() * 100;
            const tx = Math.cos(angle) * velocity + 'px';
            const ty = Math.sin(angle) * velocity + 'px';
            
            p.style.setProperty('--tx', tx);
            p.style.setProperty('--ty', ty);
            p.style.left = centerX + 'px';
            p.style.top = centerY + 'px';
            p.style.width = (4 + Math.random() * 6) + 'px';
            p.style.height = p.style.width;
            p.style.backgroundColor = COLORS[Math.floor(Math.random() * COLORS.length)];
            
            DOM.particles.appendChild(p);
            
            setTimeout(() => p.remove(), 800);
        }
    }

    function showFloatingText(text) {
        const el = document.createElement('div');
        el.className = 'floating-text';
        el.innerText = text;
        
        const rect = DOM.board.getBoundingClientRect();
        el.style.top = (rect.top + rect.height / 2 - 20) + 'px';
        el.style.left = rect.left + 'px';
        
        document.body.appendChild(el);
        
        setTimeout(() => el.remove(), 1000);
    }

    function updateScore(val) {
        state.score = val;
        DOM.score.innerText = state.score;
        if (state.score > state.highScore) {
            state.highScore = state.score;
            DOM.highScore.innerText = state.highScore;
            localStorage.setItem('blockPuzzleHighScore', state.highScore);
        }
    }

    function checkGameOverCondition() {
        setTimeout(() => {
            const remaining = document.querySelectorAll('.piece-wrapper .draggable-piece');
            if (remaining.length === 0) return;

            let canMove = false;
            remaining.forEach(piece => {
                if (canMove) return;
                const shape = JSON.parse(piece.dataset.shape);
                
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (canPlace(shape, r, c)) {
                            canMove = true;
                            break;
                        }
                    }
                }
            });

            // Se non ci sono mosse, controlla se il giocatore ha abbastanza soldi per comprare un powerup che potrebbe salvarlo
            if (!canMove) {
                // Dare un attimo al giocatore per usare i powerups se ne ha
                // Ma per semplicit√†, triggeriamo game over se non usa nulla
                triggerGameOver('nomoves'); 
            }
        }, 100);
    }

    function triggerGameOver(reason) {
        stopTimer();
        AudioSys.playGameOver();
        haptic(200);
        state.isPlaying = false;
        state.bombMode = false;
        DOM.board.classList.remove('bomb-active');
        
        let msg = "";
        const texts = TRANSLATIONS[state.language];

        if (reason === 'timeout') {
            msg = texts.reason_timeout;
        } else if (reason === 'nomoves') {
            msg = texts.reason_nomoves;
        } else {
            msg = texts.reason_generic;
        }
        
        DOM.reasonText.innerText = msg;
        DOM.finalScore.innerText = state.score;
        DOM.modal.classList.add('visible');
    }

    createBoardGrid(); 
</script>
</body>
</html>